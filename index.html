<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft 3D Skin Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #6d9dc5 0%, #8fbc8f 100%);
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-height: 100vh;
        }

        .toolbar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 15px 20px;
            border-bottom: 3px solid #8b4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 10;
            flex-shrink: 0;
        }
        
        .title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .toolbar h1 {
            font-size: 20px;
            color: #ffffff;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
        }

        .minecraft-decoration {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .minecraft-block {
            width: 20px;
            height: 20px;
            border: 2px solid #000;
            position: relative;
            image-rendering: pixelated;
        }

        .block-dirt {
            background: linear-gradient(45deg, #8b4513 25%, #a0522d 25%, #a0522d 50%, #8b4513 50%, #8b4513 75%, #a0522d 75%);
            background-size: 4px 4px;
        }

        .block-grass {
            background: linear-gradient(to bottom, #9acd32 0%, #9acd32 30%, #8b4513 30%, #8b4513 70%, #a0522d 70%);
        }

        .block-stone {
            background: linear-gradient(45deg, #696969 25%, #808080 25%, #808080 50%, #696969 50%, #696969 75%, #808080 75%);
            background-size: 3px 3px;
        }

        .social-links {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 140px;
            gap: 6px;
            color: #1da1f2;
            text-decoration: none;
            font-size: 10px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: 2px solid #1da1f2;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            white-space: nowrap;
        }

        .social-link:hover {
            background: #1da1f2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .social-icon {
            width: 12px;
            height: 12px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .toolbar-row:last-child {
            margin-bottom: 0;
        }

        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 6px;
            border: 2px solid #8b4513;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.5), 0 2px 4px rgba(0,0,0,0.2);
        }

        .tool-group-label {
            font-size: 11px;
            color: #4a4a4a;
            font-weight: 700;
            margin-right: 5px;
            text-transform: uppercase;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .tool-btn {
            padding: 8px 12px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .tool-btn.export {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .tool-btn.import {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            border-color: #e65100;
        }

        .tool-btn.clear {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #b71c1c;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
        }

        .ai-generator {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .ai-input {
            flex: 1;
            min-width: 200px;
            border: 2px solid #8b4513;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .ai-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 0 0 3px rgba(76, 175, 80, 0.2);
        }

        .ai-generate-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            display: flex;
            min-width: 180px;
            line-height: 1.5;
            color: white;
            border: 2px solid #e65100;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: nowrap;
        }

        .ai-generate-btn:hover {
            background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: 2px solid #8b4513;
            border-radius: 4px;
            cursor: pointer;
            background: white;
        }

        .main-content {
            flex: 1;
            display: flex;
            background: linear-gradient(45deg, #e8f4f8 25%, #f0f8ff 25%, #f0f8ff 50%, #e8f4f8 50%, #e8f4f8 75%, #f0f8ff 75%);
            background-size: 20px 20px;
            border-left: 3px solid #8b4513;
            border-right: 3px solid #8b4513;
            min-height: 0;
            overflow: hidden;
        }

        .left-panel {
            width: 320px;
            padding: 20px;
            background: rgba(255,255,255,0.9);
            border-right: 3px solid #8b4513;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }

        .center-panel {
            flex: 1;
            padding: 20px;
            background: rgba(240,248,255,0.9);
            overflow: hidden;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .right-panel {
            width: 300px;
            padding: 20px;
            background: rgba(255,255,255,0.9);
            border-left: 3px solid #8b4513;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #4a4a4a;
            margin-bottom: 20px;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .viewer-container {
            position: relative;
            width: 100%;
            height: 100%;
            border: 3px solid #8b4513;
            border-radius: 6px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        }

        .skin-preview {
            width: 100%;
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #skinViewer {
            width: 100%;
            height: 100%;
            border-radius: 3px;
            cursor: crosshair;
        }

        .controls {
            width: 100%;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
        }

        .control-btn {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #8b4513;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #4a4a4a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: 'Courier New', monospace;
            text-align: center;
            min-width: 50px;
            height: 40px;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #e0e0e0 0%, #d0d0d0 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .layer-controls {
            background: rgba(255,255,255,0.7);
            border: 3px solid #8b4513;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .layer-toggle-btn {
            padding: 6px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            margin-right: 8px;
            margin-bottom: 8px;
            flex: 1;
            text-align: center;
        }

        .layer-toggle-btn.visible {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .layer-toggle-btn.editing {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
            border-width: 3px;
        }

        .layer-toggle-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .layer-toggle-btn.visible:hover {
            background: linear-gradient(135deg, #45a049 0%, #388e3c 100%);
        }

        .layer-toggle-btn.editing:hover {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        }

        .layer-row {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .body-parts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
        }

        .body-part-btn {
            padding: 12px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            text-align: center;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .body-part-btn.hidden {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #b71c1c;
        }

        .body-part-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .body-part-btn.hidden:hover {
            background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%);
        }

        .action-btn {
            padding: 6px 10px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            margin-right: 6px;
            margin-bottom: 6px;
            min-width: 70px;
            flex: 1;
        }

        .action-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .action-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .grid-tool-btn {
            padding: 10px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            text-align: center;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-tool-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .grid-tool-btn.active {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
        }

        .grid-tool-btn.active:hover {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        }

        .hidden-file-input {
            display: none;
        }

        .status-bar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 12px 20px;
            font-size: 12px;
            color: #ffffff;
            border-top: 3px solid #8b4513;
            font-family: 'Courier New', monospace;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            z-index: 10;
            min-height: 50px;
            flex-shrink: 0;
            border-left: 3px solid #8b4513;
            border-right: 3px solid #8b4513;
            border-bottom: 3px solid #8b4513;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .edit-mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
        }

        .color-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .color-code-input {
            width: 80px;
            border: 2px solid #8b4513;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            background: white;
        }

        .color-apply-btn {
            padding: 6px 10px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .color-apply-btn:hover {
            background: linear-gradient(135deg, #45a049 0%, #388e3c 100%);
            transform: translateY(-1px);
        }

        @media (max-width: 1200px) {
            .left-panel, .right-panel {
                width: 250px;
            }
            
            .social-link {
                min-width: 120px;
                font-size: 9px;
                padding: 4px 8px;
            }
        }

        @media (max-width: 768px) {
            .title-bar {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .social-links {
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100%;
                height: auto;
                min-height: 200px;
            }
            
            .center-panel {
                width: 100%;
                min-height: 400px;
            }

            .layer-row {
                flex-direction: column;
                gap: 8px;
            }

            .tools-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="toolbar">
            <div class="title-bar">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <h1>🎨 Minecraft 3D Skin Editor</h1>
                    <div class="minecraft-decoration">
                        <div class="minecraft-block block-grass"></div>
                        <div class="minecraft-block block-dirt"></div>
                        <div class="minecraft-block block-stone"></div>
                    </div>
                </div>
                <div class="social-links">
                    <a href="https://discord.gg/RKjspnTBmb" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M19.952,5.672c-1.904-1.531-4.916-1.79-5.044-1.801c-0.201-0.017-0.392,0.097-0.474,0.281 c-0.006,0.012-0.072,0.163-0.145,0.398c1.259,0.212,2.806,0.64,4.206,1.509c0.224,0.139,0.293,0.434,0.154,0.659 c-0.09,0.146-0.247,0.226-0.407,0.226c-0.086,0-0.173-0.023-0.252-0.072C15.584,5.38,12.578,5.305,12,5.305S8.415,5.38,6.011,6.872 c-0.225,0.14-0.519,0.07-0.659-0.154c-0.14-0.225-0.07-0.519,0.154-0.659c1.4-0.868,2.946-1.297,4.206-1.509 c-0.074-0.236-0.14-0.386-0.145-0.398C9.484,3.968,9.294,3.852,9.092,3.872c-0.127,0.01-3.139,0.269-5.069,1.822 C3.015,6.625,1,12.073,1,16.783c0,0.083,0.022,0.165,0.063,0.237c1.391,2.443,5.185,3.083,6.05,3.111c0.005,0,0.01,0,0.015,0 c0.153,0,0.297-0.073,0.387-0.197l0.875-1.202c-2.359-0.61-3.564-1.645-3.634-1.706c-0.198-0.175-0.217-0.477-0.042-0.675 c0.175-0.198,0.476-0.217,0.674-0.043c0.029,0.026,2.248,1.909,6.612,1.909c4.372,0,6.591-1.891,6.613-1.91 c0.198-0.172,0.5-0.154,0.674,0.045c0.174,0.198,0.155,0.499-0.042,0.673c-0.07,0.062-1.275,1.096-3.634,1.706l0.875,1.202 c0.09,0.124,0.234,0.197,0.387,0.197c0.005,0,0.01,0,0.015,0c0.865-0.027,4.659-0.667,6.05-3.111 C22.978,16.947,23,16.866,23,16.783C23,12.073,20.985,6.625,19.952,5.672z M8.891,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913s1.674,0.857,1.674,1.913S9.816,14.87,8.891,14.87z M15.109,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913c0.924,0,1.674,0.857,1.674,1.913S16.033,14.87,15.109,14.87z"></path>
                        </svg>
                        Discord Server
                    </a>
                    <a href="https://github.com/aeromechanic000/minecraft-ai-oc-creator" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path>
                        </svg>
                        GitHub Repository 
                    </a>
                    <a href="https://x.com/aeromechan71402" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path>
                        </svg>
                        @aeromechan71402
                    </a>
                </div>
            </div>
            
            <div class="toolbar-row">
                <div class="tool-group">
                    <span class="tool-group-label">📂 File</span>
                    <input type="file" id="import-skin" accept=".png" class="hidden-file-input">
                    <button onclick="document.getElementById('import-skin').click()" class="tool-btn import">Import PNG</button>
                    <button onclick="exportSkin()" class="tool-btn export">Export PNG</button>
                    <button onclick="newSkin()" class="tool-btn">New Skin</button>
                    <button onclick="clearSkin()" class="tool-btn clear">Clear</button>
                </div>

                <div class="ai-generator">
                    <input type="text" class="ai-input" id="ai-input" placeholder="Describe skin modifications (e.g., 'Add red stripes to the shirt')">
                    <button id="ai-generate-btn" class="ai-generate-btn">
                        <span>🤖 Generate Modifications</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">📋 Display Options</div>
                    <div class="layer-row">
                        <button id="layer-body" class="layer-toggle-btn visible" onclick="toggleLayerVisibility('body')">Body</button>
                        <button id="layer-outer" class="layer-toggle-btn" onclick="toggleLayerVisibility('outer')">Outer</button>
                        <button id="pixel-grid-btn" class="layer-toggle-btn visible" onclick="togglePixelGrid()">Grid</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">👤 Body Parts</div>
                    <div class="body-parts-grid">
                        <button class="body-part-btn" id="part-head" onclick="toggleBodyPart('head')">👤 Head</button>
                        <button class="body-part-btn" id="part-body" onclick="toggleBodyPart('body')">🎽 Body</button>
                        <button class="body-part-btn" id="part-leftarm" onclick="toggleBodyPart('leftarm')">🤳 L.Arm</button>
                        <button class="body-part-btn" id="part-rightarm" onclick="toggleBodyPart('rightarm')">💪 R.Arm</button>
                        <button class="body-part-btn" id="part-leftleg" onclick="toggleBodyPart('leftleg')">🦵 L.Leg</button>
                        <button class="body-part-btn" id="part-rightleg" onclick="toggleBodyPart('rightleg')">🏃 R.Leg</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🔧 Actions</div>
                    <div class="action-row">
                        <button onclick="undoAction()" class="action-btn">↶ Undo</button>
                        <button onclick="redoAction()" class="action-btn">↷ Redo</button>
                    </div>
                    <div class="action-row">
                        <button onclick="mirrorSkin()" class="action-btn">🪞 Mirror</button>
                        <button onclick="flipSkin()" class="action-btn">🔄 Flip</button>
                    </div>
                </div>
            </div>
            
            <div class="center-panel">
                <div class="viewer-container">
                    <div class="edit-mode-indicator" id="edit-mode-indicator">Editing: Body Layer</div>
                    <div class="skin-preview">
                        <canvas id="skinViewer"></canvas>
                    </div>
                    <div class="controls">
                        <button id="resetView" class="control-btn">🔄 Reset View</button>
                        <button id="toggleMode" class="control-btn">🔄 Toggle Mode</button>
                        <button id="zoomIn" class="control-btn">🔍 Zoom+</button>
                        <button id="zoomOut" class="control-btn">🔍 Zoom-</button>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🎯 Common Colors</div>
                    <div id="color-palette" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-bottom: 15px;">
                        <!-- Color swatches will be generated here -->
                    </div>
                    
                    <div class="color-input-group">
                        <input type="text" id="color-code-input" class="color-code-input" placeholder="#8B4513" value="#8B4513">
                        <button onclick="applyColorCode()" class="color-apply-btn">Apply</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🎨 3D Tools</div>
                    <div class="tools-grid">
                        <button id="tool-pen" class="grid-tool-btn active" onclick="setTool('pen')">✏️ Pen</button>
                        <button id="tool-brush" class="grid-tool-btn" onclick="setTool('brush')">🖌️ Brush</button>
                        <button id="tool-eyedropper" class="grid-tool-btn" onclick="setTool('eyedropper')">💧 Picker</button>
                        <button id="tool-rotate" class="grid-tool-btn" onclick="setTool('rotate')">🔄 Rotate</button>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label style="font-size: 12px; font-weight: bold; color: #4a4a4a; margin-bottom: 8px; display: block;">Current Color:</label>
                        <input type="color" id="color-picker" class="color-picker" value="#8B4513" style="width: 100%;">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-info">
                <span id="status-text">🎨 3D Paint Mode - Click on the model to paint pixels!</span>
                <span id="pixel-info">Editing: Body Layer | Tool: Pen</span>
                <span id="camera-info">Camera: Free | Zoom: 100%</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let skinModel, gridOverlay;
        let currentTool = 'pen';
        let currentEditingLayer = 'body';
        let currentColor = '#8B4513';
        let showPixelGrid = true;
        let isEditMode = true;

        // Layer visibility states
        let layerVisibility = {
            body: true,
            outer: false
        };

        // Interaction variables
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let hoveredFace = null;
        let isDragging = false;
        let isRotating = false;
        let dragStart = new THREE.Vector2();
        let lastPaintedVoxel = null; // Track the last painted voxel to prevent multiple paints

        // Skin data
        let skinData = {
            body: new Uint8ClampedArray(64 * 64 * 4),
            outer: new Uint8ClampedArray(64 * 64 * 4)
        };

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;

        // Body parts visibility
        let bodyPartsVisible = {
            head: true,
            body: true,
            leftarm: true,
            rightarm: true,
            leftleg: true,
            rightleg: true
        };

        // 36 Common Minecraft colors palette
        let commonColors = [
            '#8B4513', '#F4A460', '#DEB887', '#D2691E', '#654321', '#A0522D',  // Browns/Skin tones
            '#FF0000', '#FF4500', '#FF6347', '#DC143C', '#8B0000', '#B22222',  // Reds
            '#0000FF', '#4169E1', '#1E90FF', '#87CEEB', '#000080', '#191970',  // Blues
            '#228B22', '#32CD32', '#00FF00', '#ADFF2F', '#006400', '#9ACD32',  // Greens
            '#800080', '#9932CC', '#DA70D6', '#FF69B4', '#4B0082', '#8A2BE2',  // Purples
            '#FFFF00', '#FFD700', '#FFA500', '#FF8C00', '#DAA520', '#B8860B',  // Yellows/Golds
            '#000000', '#2F2F2F', '#696969', '#808080', '#C0C0C0', '#FFFFFF'   // Grays
        ];

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initScene();
            initSkinData();
            setupEventListeners();
            generateColorPalette();
            createSkinModel();
            createGridOverlay();
            updateLayerDisplay();
            updateLayerButtons();
            updatePixelGridButton();
            updateStatus('🎨 3D Skin Editor loaded - Start with an empty skin!');
        });

        function initScene() {
            const container = document.querySelector('.skin-preview');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 6, 5);
            camera.lookAt(0, 6, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('skinViewer'),
                antialias: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Simple orbit controls
            setupCameraControls();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function setupCameraControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            event.preventDefault();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            dragStart.copy(mouse);
            isDragging = true;
            lastPaintedVoxel = null; // Reset painted voxel tracking
            
            // Right button (2) always rotates
            if (event.button === 2) {
                isRotating = true;
                return;
            }
            
            // Left button behavior
            if (event.button === 0) {
                if ((currentTool === 'pen' || currentTool === 'brush') && isEditMode) {
                    paintFace();
                } else if (currentTool === 'eyedropper' && isEditMode) {
                    pickColor();
                } else if (currentTool === 'rotate' || !isEditMode) {
                    isRotating = true;
                }
            }
        }

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycasting for hover effects (only in edit mode)
            if (isEditMode && !isRotating) {
                updateFaceHover();
            }
            
            if (isDragging) {
                if (isRotating) {
                    const deltaX = mouse.x - dragStart.x;
                    const deltaY = mouse.y - dragStart.y;
                    
                    // Rotate camera around target
                    const spherical = new THREE.Spherical();
                    const targetPosition = new THREE.Vector3(0, 6, 0);
                    const offset = camera.position.clone().sub(targetPosition);
                    spherical.setFromVector3(offset);
                    spherical.theta -= deltaX * 2;
                    spherical.phi += deltaY * 2;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical).add(targetPosition);
                    camera.lookAt(targetPosition);
                    
                    dragStart.copy(mouse);
                } else if ((currentTool === 'pen' || currentTool === 'brush') && isEditMode) {
                    paintFace();
                }
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            isRotating = false;
            lastPaintedVoxel = null; // Reset when mouse is released
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            const zoomSpeed = 0.1;
            const direction = event.deltaY > 0 ? 1 : -1;
            const targetPosition = new THREE.Vector3(0, 6, 0);
            
            const offset = camera.position.clone().sub(targetPosition);
            offset.multiplyScalar(1 + direction * zoomSpeed);
            
            // Limit zoom
            const distance = offset.length();
            if (distance < 3) offset.setLength(3);
            if (distance > 12) offset.setLength(12);
            
            camera.position.copy(targetPosition).add(offset);
            camera.lookAt(targetPosition);
            
            updateCameraInfo();
        }

        function updateFaceHover() {
            raycaster.setFromCamera(mouse, camera);
            
            if (skinModel) {
                // Get all visible meshes from current editing layer only
                const editingLayerMeshes = [];
                
                skinModel.children.forEach(layerGroup => {
                    if (layerGroup.visible && layerGroup.name === `${currentEditingLayer}_layer`) {
                        layerGroup.children.forEach(partGroup => {
                            if (partGroup.visible) {
                                partGroup.children.forEach(mesh => {
                                    if (mesh.visible && mesh.material.opacity > 0) {
                                        editingLayerMeshes.push(mesh);
                                    }
                                });
                            }
                        });
                    }
                });
                
                // Only intersect with current editing layer meshes
                const intersects = raycaster.intersectObjects(editingLayerMeshes, false);
                
                // Clear previous hover
                if (hoveredFace) {
                    hoveredFace.material.emissive.setHex(0x000000);
                    hoveredFace = null;
                }
                
                // Hover the closest face from the current editing layer
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const face = intersect.object;
                    
                    if (face.userData && face.userData.layer === currentEditingLayer) {
                        hoveredFace = face;
                        face.material.emissive.setHex(0x404040);
                    }
                }
            }
        }

        function paintFace() {
            if (!hoveredFace || !hoveredFace.userData) return;
            
            const { voxelX, voxelY, voxelZ, layer } = hoveredFace.userData;
            
            // Only paint if it's the current editing layer
            if (layer !== currentEditingLayer) return;
            
            // Create unique voxel identifier to prevent multiple paints of the same voxel
            const voxelId = `${voxelX},${voxelY},${voxelZ},${layer}`;
            
            // Skip if we already painted this voxel in this paint session
            if (lastPaintedVoxel === voxelId) return;
            
            // Save state for undo (only on first paint of a session)
            if (lastPaintedVoxel === null) {
                saveUndoState();
            }
            
            // Mark this voxel as painted
            lastPaintedVoxel = voxelId;
            
            // Get proper texture coordinates for this specific voxel
            const texCoords = getVoxelTextureCoords(voxelX, voxelY, voxelZ);
            if (!texCoords) return;
            
            const { x: textureX, y: textureY } = texCoords;
            
            if (currentTool === 'pen') {
                paintPixelPen(textureX, textureY);
            } else if (currentTool === 'brush') {
                paintPixelBrush(textureX, textureY);
            }
            
            updateSkinTextures();
        }

        function pickColor() {
            if (!hoveredFace || !hoveredFace.userData) return;
            
            const { voxelX, voxelY, voxelZ, layer } = hoveredFace.userData;
            
            // Only pick from current editing layer
            if (layer !== currentEditingLayer) return;
            
            // Get proper texture coordinates for this specific voxel
            const texCoords = getVoxelTextureCoords(voxelX, voxelY, voxelZ);
            if (!texCoords) return;
            
            const { x: textureX, y: textureY } = texCoords;
            
            const color = getPixelColor(textureX, textureY, layer);
            
            currentColor = color;
            document.getElementById('color-picker').value = color;
            document.getElementById('color-code-input').value = color;
            updateStatus(`Color picked: ${color}`);
        }

        function initSkinData() {
            // Initialize both layers as completely transparent/empty
            for (let i = 0; i < skinData.body.length; i += 4) {
                skinData.body[i] = 0;        // R
                skinData.body[i + 1] = 0;    // G
                skinData.body[i + 2] = 0;    // B
                skinData.body[i + 3] = 0;    // A (transparent)
            }
            
            for (let i = 0; i < skinData.outer.length; i += 4) {
                skinData.outer[i] = 0;       // R
                skinData.outer[i + 1] = 0;   // G
                skinData.outer[i + 2] = 0;   // B
                skinData.outer[i + 3] = 0;   // A (transparent)
            }
        }

        // Pen tool - draws with exact current color
        function paintPixelPen(x, y) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return;
            
            const rgb = hexToRgb(currentColor);
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            
            const index = (y * 64 + x) * 4;
            data[index] = rgb.r;
            data[index + 1] = rgb.g;
            data[index + 2] = rgb.b;
            data[index + 3] = 255;
        }

        // Brush tool - draws with random brightness shift of current color
        function paintPixelBrush(x, y) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return;
            
            const rgb = hexToRgb(currentColor);
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            
            // Random brightness shift between -30 and +30
            const brightnessShift = (Math.random() - 0.5) * 60;
            
            // Apply brightness shift to each color component
            let newR = Math.round(rgb.r + brightnessShift);
            let newG = Math.round(rgb.g + brightnessShift);
            let newB = Math.round(rgb.b + brightnessShift);
            
            // Clamp values between 0 and 255
            newR = Math.max(0, Math.min(255, newR));
            newG = Math.max(0, Math.min(255, newG));
            newB = Math.max(0, Math.min(255, newB));
            
            const index = (y * 64 + x) * 4;
            data[index] = newR;
            data[index + 1] = newG;
            data[index + 2] = newB;
            data[index + 3] = 255;
        }

        function getPixelColor(x, y, layer) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return '#000000';
            
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (y * 64 + x) * 4;
            
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            
            if (a === 0) return '#000000'; // Transparent pixel
            
            return rgbToHex(r, g, b);
        }

        function createSkinModel() {
            skinModel = new THREE.Group();
            
            // Create body and outer layer groups
            const bodyGroup = new THREE.Group();
            const outerGroup = new THREE.Group();
            
            // Create surface meshes for body parts - only surface voxels
            createBodyPartSurfaces(bodyGroup, 'body', 1.0);
            createBodyPartSurfaces(outerGroup, 'outer', 1.25); // 25% larger for proper clothing effect
            
            bodyGroup.name = 'body_layer';
            outerGroup.name = 'outer_layer';
            
            skinModel.add(bodyGroup);
            skinModel.add(outerGroup);
            
            scene.add(skinModel);
        }

        function createBodyPartSurfaces(parentGroup, layer, scale) {
            // Head surfaces (8x8x8) - only surface voxels
            const headGroup = createPartSurfaces('head', -4, 4, 50, 58, -4, 4, layer, scale);
            
            // Body surfaces (8x12x4) - only surface voxels  
            const bodyGroup = createPartSurfaces('body', -4, 4, 38, 50, -2, 2, layer, scale);
            
            // Right arm surfaces (4x12x4) - only surface voxels
            const rightArmGroup = createPartSurfaces('rightarm', -7, -3, 38, 50, -2, 2, layer, scale);
            
            // Left arm surfaces (4x12x4) - only surface voxels
            const leftArmGroup = createPartSurfaces('leftarm', 3, 7, 38, 50, -2, 2, layer, scale);
            
            // Right leg surfaces (4x12x4) - only surface voxels
            const rightLegGroup = createPartSurfaces('rightleg', -4, 0, 26, 38, -2, 2, layer, scale);
            
            // Left leg surfaces (4x12x4) - only surface voxels
            const leftLegGroup = createPartSurfaces('leftleg', 0, 4, 26, 38, -2, 2, layer, scale);
            
            parentGroup.add(headGroup);
            parentGroup.add(bodyGroup);
            parentGroup.add(rightArmGroup);
            parentGroup.add(leftArmGroup);
            parentGroup.add(rightLegGroup);
            parentGroup.add(leftLegGroup);
        }

        function createPartSurfaces(partName, xMin, xMax, yMin, yMax, zMin, zMax, layer, scale) {
            const partGroup = new THREE.Group();
            partGroup.name = `${partName}_${layer}`;
            
            const voxelSize = 0.125 * scale;
            
            // For outer layer, we need to offset the position to be centered around the body
            const offsetMultiplier = layer === 'outer' ? (scale - 1.0) / 2.0 : 0;
            
            // Create only surface voxels - check if voxel is on the boundary
            for (let x = xMin; x < xMax; x++) {
                for (let y = yMin; y < yMax; y++) {
                    for (let z = zMin; z < zMax; z++) {
                        // Check if voxel is on any surface (boundary)
                        if (isOnSurface(x, y, z, xMin, xMax, yMin, yMax, zMin, zMax)) {
                            createVoxelSurfaces(partGroup, x, y, z, voxelSize, layer, partName, offsetMultiplier);
                        }
                    }
                }
            }
            
            return partGroup;
        }

        function isOnSurface(x, y, z, xMin, xMax, yMin, yMax, zMin, zMax) {
            // A voxel is on the surface if it's on any boundary
            return (
                x === xMin || x === xMax - 1 ||  // Left or right face
                y === yMin || y === yMax - 1 ||  // Bottom or top face
                z === zMin || z === zMax - 1     // Front or back face
            );
        }

        function createVoxelSurfaces(parentGroup, voxelX, voxelY, voxelZ, voxelSize, layer, partName, offsetMultiplier = 0) {
            // Get texture coordinates for this specific voxel
            const texCoords = getVoxelTextureCoords(voxelX, voxelY, voxelZ);
            if (!texCoords) return;
            
            const { x: textureX, y: textureY } = texCoords;
            
            // Create 6 face geometries but only show faces that are actually on the surface
            const faceGeometry = new THREE.PlaneGeometry(voxelSize, voxelSize);
            
            // Define face positions and rotations
            const faces = [
                { pos: [voxelSize/2, 0, 0], rot: [0, Math.PI/2, 0], name: 'right' },
                { pos: [-voxelSize/2, 0, 0], rot: [0, -Math.PI/2, 0], name: 'left' },
                { pos: [0, voxelSize/2, 0], rot: [-Math.PI/2, 0, 0], name: 'top' },
                { pos: [0, -voxelSize/2, 0], rot: [Math.PI/2, 0, 0], name: 'bottom' },
                { pos: [0, 0, voxelSize/2], rot: [0, 0, 0], name: 'front' },
                { pos: [0, 0, -voxelSize/2], rot: [0, Math.PI, 0], name: 'back' }
            ];
            
            faces.forEach(face => {
                // Get material properties based on layer and texture data
                const materialProps = getVoxelMaterial(textureX, textureY, layer);
                
                const material = new THREE.MeshLambertMaterial({
                    color: materialProps.color,
                    transparent: true,
                    opacity: materialProps.opacity,
                    side: THREE.DoubleSide
                });
                
                const faceMesh = new THREE.Mesh(faceGeometry, material);
                
                // FIXED: Position faces at the center of each grid cell
                // Convert voxel coordinates to world coordinates and center within grid cell
                const baseX = (voxelX + 0.5) * 0.125; // +0.5 centers the voxel in its grid cell
                const baseY = (voxelY + 0.5) * 0.125;
                const baseZ = (voxelZ + 0.5) * 0.125;
                
                // Apply offset for outer layer to make it surround the body layer
                const offsetX = offsetMultiplier * Math.sign(baseX || 1);
                const offsetY = offsetMultiplier * Math.sign(baseY || 1);
                const offsetZ = offsetMultiplier * Math.sign(baseZ || 1);
                
                faceMesh.position.set(
                    baseX + face.pos[0] + offsetX,
                    baseY + face.pos[1] + offsetY,
                    baseZ + face.pos[2] + offsetZ
                );
                
                faceMesh.rotation.set(face.rot[0], face.rot[1], face.rot[2]);
                
                faceMesh.userData = {
                    textureX,
                    textureY,
                    layer,
                    partName,
                    voxelX,
                    voxelY,
                    voxelZ,
                    face: face.name
                };
                
                parentGroup.add(faceMesh);
            });
        }

        function getVoxelMaterial(textureX, textureY, layer) {
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (textureY * 64 + textureX) * 4;
            
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            
            if (a === 0) {
                // Empty pixel
                if (layer === 'outer') {
                    // For outer layer, completely transparent when empty
                    return {
                        color: 0x000000,
                        opacity: 0.0
                    };
                } else {
                    // For body layer, show grid when empty
                    return {
                        color: showPixelGrid ? 0x404040 : 0x202020,
                        opacity: showPixelGrid ? 0.2 : 0.0
                    };
                }
            }
            
            return {
                color: (r << 16) | (g << 8) | b,
                opacity: 1.0
            };
        }

        // Fixed texture coordinate mapping function
        function getVoxelTextureCoords(voxelX, voxelY, voxelZ) {
            // Map 3D voxel coordinates to proper 2D texture coordinates
            // This is crucial for correct pixel painting
            
            // Head area (Y: 50-57, 8 units tall)
            if (voxelY >= 50 && voxelY <= 57) {
                // Head front face mapping
                const localX = voxelX + 4; // Convert to 0-7 range
                const localY = 57 - voxelY; // Convert to 0-7 range (flip Y)
                return {
                    x: 8 + localX,
                    y: 8 + localY
                };
            }
            
            // Body area (Y: 38-49, 12 units tall)
            if (voxelY >= 38 && voxelY <= 49) {
                // Body front face mapping
                const localX = voxelX + 4; // Convert to 0-7 range
                const localY = 49 - voxelY; // Convert to 0-11 range (flip Y)
                return {
                    x: 20 + localX,
                    y: 20 + localY
                };
            }
            
            // Legs area (Y: 26-37, 12 units tall)
            if (voxelY >= 26 && voxelY <= 37) {
                // Right leg (X: -4 to -1) and Left leg (X: 0 to 3)
                if (voxelX >= -4 && voxelX <= -1) {
                    // Right leg front face mapping
                    const localX = voxelX + 4; // Convert to 0-3 range
                    const localY = 37 - voxelY; // Convert to 0-11 range (flip Y)
                    return {
                        x: 4 + localX,
                        y: 20 + localY
                    };
                } else if (voxelX >= 0 && voxelX <= 3) {
                    // Left leg front face mapping
                    const localX = voxelX; // Already 0-3 range
                    const localY = 37 - voxelY; // Convert to 0-11 range (flip Y)
                    return {
                        x: 20 + localX,
                        y: 52 + localY
                    };
                }
            }
            
            // Arms area (Y: 38-49, 12 units tall)
            if (voxelY >= 38 && voxelY <= 49) {
                // Right arm (X: -7 to -4) and Left arm (X: 3 to 6)
                if (voxelX >= -7 && voxelX <= -4) {
                    // Right arm front face mapping
                    const localX = voxelX + 7; // Convert to 0-3 range
                    const localY = 49 - voxelY; // Convert to 0-11 range (flip Y)
                    return {
                        x: 44 + localX,
                        y: 20 + localY
                    };
                } else if (voxelX >= 3 && voxelX <= 6) {
                    // Left arm front face mapping
                    const localX = voxelX - 3; // Convert to 0-3 range
                    const localY = 49 - voxelY; // Convert to 0-11 range (flip Y)
                    return {
                        x: 36 + localX,
                        y: 52 + localY
                    };
                }
            }
            
            // Default fallback
            return {
                x: Math.max(0, Math.min(63, Math.floor(voxelX + 32))),
                y: Math.max(0, Math.min(63, Math.floor(voxelZ + 32)))
            };
        }

        function getVoxelFaceColor(textureX, textureY, layer) {
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (textureY * 64 + textureX) * 4;
            
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            
            if (a === 0) {
                // Empty pixel - show grid color only for body layer
                if (layer === 'outer') {
                    return 0x000000; // Invisible for outer layer
                }
                return showPixelGrid ? 0x404040 : 0x202020;
            }
            
            return (r << 16) | (g << 8) | b;
        }

        function getVoxelFaceOpacity(textureX, textureY, layer) {
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (textureY * 64 + textureX) * 4;
            const a = data[index + 3];
            
            if (a === 0) {
                // Empty pixel
                if (layer === 'outer') {
                    return 0.0; // Completely transparent for outer layer
                }
                return showPixelGrid ? 0.2 : 0.0; // Faint for body layer grid
            }
            
            return 1.0;
        }

        function createGridOverlay() {
            gridOverlay = new THREE.Group();
            
            if (showPixelGrid) {
                // Only show grid for visible layers
                if (layerVisibility.body) {
                    const gridMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.6,
                        linewidth: 2
                    });
                    
                    // Create wireframe grids for body layer - only surface boundaries
                    createPartGrid('head_body', -4, 4, 50, 58, -4, 4, gridMaterial, 1.0, false);
                    createPartGrid('body_body', -4, 4, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('rightarm_body', -7, -3, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('leftarm_body', 3, 7, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('rightleg_body', -4, 0, 26, 38, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('leftleg_body', 0, 4, 26, 38, -2, 2, gridMaterial, 1.0, false);
                }
                
                // Only show outer grid when outer layer is visible
                if (layerVisibility.outer) {
                    const outerGridMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xff6600, // Orange color for outer layer grid
                        transparent: true, 
                        opacity: 0.4,
                        linewidth: 1
                    });
                    
                    createPartGrid('head_outer', -4, 4, 50, 58, -4, 4, outerGridMaterial, 1.25, true);
                    createPartGrid('body_outer', -4, 4, 38, 50, -2, 2, outerGridMaterial, 1.25, true);
                    createPartGrid('rightarm_outer', -7, -3, 38, 50, -2, 2, outerGridMaterial, 1.25, true);
                    createPartGrid('leftarm_outer', 3, 7, 38, 50, -2, 2, outerGridMaterial, 1.25, true);
                    createPartGrid('rightleg_outer', -4, 0, 26, 38, -2, 2, outerGridMaterial, 1.25, true);
                    createPartGrid('leftleg_outer', 0, 4, 26, 38, -2, 2, outerGridMaterial, 1.25, true);
                }
            }
            
            scene.add(gridOverlay);
        }

        function createPartGrid(partName, xMin, xMax, yMin, yMax, zMin, zMax, material, scale, isOuter = false) {
            const voxelSize = 0.125 * scale;
            const partGrid = new THREE.Group();
            partGrid.name = `grid_${partName}`;
            
            // For outer layer grid, apply same offset as the voxels
            const offsetMultiplier = isOuter ? (scale - 1.0) / 2.0 : 0;
            
            // FIXED: Create grid lines that align with voxel centers
            // Grid lines should be positioned to form the boundaries of voxel cells
            for (let x = xMin; x <= xMax; x++) {
                for (let y = yMin; y <= yMax; y++) {
                    // Convert voxel coordinates to world coordinates (centered)
                    const baseX = x * 0.125;
                    const baseY = y * 0.125;
                    const offsetX = isOuter ? offsetMultiplier * Math.sign(baseX || 1) : 0;
                    const offsetY = isOuter ? offsetMultiplier * Math.sign(baseY || 1) : 0;
                    
                    // Z lines only on front and back faces
                    if ((x === xMin || x === xMax) || (y === yMin || y === yMax)) {
                        const zMinOffset = isOuter ? offsetMultiplier * Math.sign(zMin * 0.125 || 1) : 0;
                        const zMaxOffset = isOuter ? offsetMultiplier * Math.sign(zMax * 0.125 || 1) : 0;
                        
                        const zGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(baseX + offsetX, baseY + offsetY, zMin * 0.125 + zMinOffset),
                            new THREE.Vector3(baseX + offsetX, baseY + offsetY, zMax * 0.125 + zMaxOffset)
                        ]);
                        partGrid.add(new THREE.Line(zGeometry, material));
                    }
                }
                
                for (let z = zMin; z <= zMax; z++) {
                    const baseX = x * 0.125;
                    const baseZ = z * 0.125;
                    const offsetX = isOuter ? offsetMultiplier * Math.sign(baseX || 1) : 0;
                    const offsetZ = isOuter ? offsetMultiplier * Math.sign(baseZ || 1) : 0;
                    
                    // Y lines only on side faces
                    if ((x === xMin || x === xMax) || (z === zMin || z === zMax)) {
                        const yMinOffset = isOuter ? offsetMultiplier * Math.sign(yMin * 0.125 || 1) : 0;
                        const yMaxOffset = isOuter ? offsetMultiplier * Math.sign(yMax * 0.125 || 1) : 0;
                        
                        const yGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(baseX + offsetX, yMin * 0.125 + yMinOffset, baseZ + offsetZ),
                            new THREE.Vector3(baseX + offsetX, yMax * 0.125 + yMaxOffset, baseZ + offsetZ)
                        ]);
                        partGrid.add(new THREE.Line(yGeometry, material));
                    }
                }
            }
            
            for (let y = yMin; y <= yMax; y++) {
                for (let z = zMin; z <= zMax; z++) {
                    const baseY = y * 0.125;
                    const baseZ = z * 0.125;
                    const offsetY = isOuter ? offsetMultiplier * Math.sign(baseY || 1) : 0;
                    const offsetZ = isOuter ? offsetMultiplier * Math.sign(baseZ || 1) : 0;
                    
                    // X lines only on top/bottom faces
                    if ((y === yMin || y === yMax) || (z === zMin || z === zMax)) {
                        const xMinOffset = isOuter ? offsetMultiplier * Math.sign(xMin * 0.125 || 1) : 0;
                        const xMaxOffset = isOuter ? offsetMultiplier * Math.sign(xMax * 0.125 || 1) : 0;
                        
                        const xGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(xMin * 0.125 + xMinOffset, baseY + offsetY, baseZ + offsetZ),
                            new THREE.Vector3(xMax * 0.125 + xMaxOffset, baseY + offsetY, baseZ + offsetZ)
                        ]);
                        partGrid.add(new THREE.Line(xGeometry, material));
                    }
                }
            }
            
            gridOverlay.add(partGrid);
        }

        function updateSkinTextures() {
            if (!skinModel) return;
            
            // Update all face materials
            skinModel.children.forEach(layerGroup => {
                layerGroup.children.forEach(partGroup => {
                    partGroup.children.forEach(face => {
                        if (face.userData) {
                            const { voxelX, voxelY, voxelZ, layer } = face.userData;
                            
                            // Get proper texture coordinates for this voxel
                            const texCoords = getVoxelTextureCoords(voxelX, voxelY, voxelZ);
                            if (texCoords) {
                                const material = getVoxelMaterial(texCoords.x, texCoords.y, layer);
                                face.material.color.setHex(material.color);
                                face.material.opacity = material.opacity;
                                face.visible = material.opacity > 0 || layerVisibility[layer];
                            }
                        }
                    });
                });
            });
        }

        function setupEventListeners() {
            // Tool events
            document.getElementById('color-picker').addEventListener('change', (e) => {
                currentColor = e.target.value;
                document.getElementById('color-code-input').value = e.target.value;
            });
            
            // Control buttons
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('toggleMode').addEventListener('click', toggleMode);
            document.getElementById('zoomIn').addEventListener('click', () => zoomCamera(0.9));
            document.getElementById('zoomOut').addEventListener('click', () => zoomCamera(1.1));
            
            // Import file event
            document.getElementById('import-skin').addEventListener('change', importSkin);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        }

        function handleKeyboard(event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key) {
                    case 'z':
                        event.preventDefault();
                        if (event.shiftKey) {
                            redoAction();
                        } else {
                            undoAction();
                        }
                        break;
                    case 'y':
                        event.preventDefault();
                        redoAction();
                        break;
                }
            }
            
            switch (event.key) {
                case 'p':
                    setTool('pen');
                    break;
                case 'b':
                    setTool('brush');
                    break;
                case 'i':
                    setTool('eyedropper');
                    break;
                case 'r':
                    setTool('rotate');
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.querySelector('.skin-preview');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Tool functions
        function setTool(tool) {
            currentTool = tool;
            
            document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tool-${tool}`).classList.add('active');
            
            // Update cursor based on tool and mode
            const canvas = renderer.domElement;
            if (tool === 'rotate' || !isEditMode) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            // Update status with tool descriptions
            let toolDescription = '';
            switch(tool) {
                case 'pen':
                    toolDescription = 'Pen Tool - draws with exact current color';
                    break;
                case 'brush':
                    toolDescription = 'Brush Tool - draws with random brightness variations';
                    break;
                case 'eyedropper':
                    toolDescription = 'Color Picker - click to pick colors from the model';
                    break;
                case 'rotate':
                    toolDescription = 'Rotate View - drag to rotate the camera';
                    break;
            }
            updateStatus(toolDescription);
        }

        // Layer functions
        function toggleLayerVisibility(layer) {
            layerVisibility[layer] = !layerVisibility[layer];
            
            // Update current editing layer based on visible layers
            updateCurrentEditingLayer();
            
            updateLayerButtons();
            updateLayerDisplay();
            updateLayerVisibility3D();
            updateGridOverlay(); // This will now show/hide grids based on layer visibility
            
            const status = layerVisibility[layer] ? 'shown' : 'hidden';
            updateStatus(`${layer} layer ${status}`);
        }

        function updateCurrentEditingLayer() {
            // Determine which layer should be edited based on visibility
            // Priority: outer layer if visible, otherwise body layer if visible
            if (layerVisibility.outer) {
                currentEditingLayer = 'outer';
            } else if (layerVisibility.body) {
                currentEditingLayer = 'body';
            } else {
                // If no layers are visible, default to body
                currentEditingLayer = 'body';
                layerVisibility.body = true; // Force body layer visible
            }
        }

        function updateLayerVisibility3D() {
            if (!skinModel) return;
            
            skinModel.children.forEach(layerGroup => {
                if (layerGroup.name === 'body_layer') {
                    layerGroup.visible = layerVisibility.body;
                } else if (layerGroup.name === 'outer_layer') {
                    layerGroup.visible = layerVisibility.outer;
                }
            });
            
            updateSkinTextures();
        }

        // Pixel grid toggle function
        function togglePixelGrid() {
            showPixelGrid = !showPixelGrid;
            updatePixelGridButton();
            updateGridOverlay(); // This will show/hide grids based on layer visibility and grid setting
            updateSkinTextures();
            
            const status = showPixelGrid ? 'shown' : 'hidden';
            updateStatus(`Pixel grid ${status}`);
        }

        function updateGridOverlay() {
            if (gridOverlay) {
                scene.remove(gridOverlay);
            }
            createGridOverlay();
        }

        function updateLayerButtons() {
            // Update layer buttons to show only visibility state
            const bodyLayerBtn = document.getElementById('layer-body');
            const outerLayerBtn = document.getElementById('layer-outer');
            
            // Body layer button
            bodyLayerBtn.classList.toggle('visible', layerVisibility.body);
            bodyLayerBtn.classList.remove('editing');
            bodyLayerBtn.textContent = 'Body';
            
            // Outer layer button
            outerLayerBtn.classList.toggle('visible', layerVisibility.outer);
            outerLayerBtn.classList.remove('editing');
            outerLayerBtn.textContent = 'Outer';
        }

        function updatePixelGridButton() {
            const gridBtn = document.getElementById('pixel-grid-btn');
            gridBtn.classList.toggle('visible', showPixelGrid);
            gridBtn.textContent = 'Grid';
        }

        function toggleBodyPart(partName) {
            bodyPartsVisible[partName] = !bodyPartsVisible[partName];
            
            const btn = document.getElementById(`part-${partName}`);
            
            // Toggle visibility for both layers of this body part
            skinModel.children.forEach(layerGroup => {
                layerGroup.children.forEach(partGroup => {
                    if (partGroup.name.includes(partName)) {
                        partGroup.visible = bodyPartsVisible[partName];
                    }
                });
            });
            
            if (bodyPartsVisible[partName]) {
                btn.classList.remove('hidden');
                updateStatus(`${partName} shown`);
            } else {
                btn.classList.add('hidden');
                updateStatus(`${partName} hidden`);
            }
        }

        function updateLayerDisplay() {
            const indicator = document.getElementById('edit-mode-indicator');
            
            if (currentEditingLayer === 'body') {
                indicator.textContent = 'Editing: Body Layer';
                indicator.style.background = 'rgba(76, 175, 80, 0.9)';
            } else {
                indicator.textContent = 'Editing: Outer Layer';
                indicator.style.background = 'rgba(255, 152, 0, 0.9)';
            }
        }

        function toggleMode() {
            isEditMode = !isEditMode;
            
            const toggleBtn = document.getElementById('toggleMode');
            const canvas = renderer.domElement;
            
            if (isEditMode) {
                toggleBtn.textContent = '👁️ View Mode';
                if (currentTool === 'rotate') {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            } else {
                toggleBtn.textContent = '🎨 Edit Mode';
                canvas.style.cursor = 'grab';
            }
        }

        function resetView() {
            camera.position.set(5, 6, 5);
            camera.lookAt(0, 6, 0);
            updateCameraInfo();
        }

        function zoomCamera(factor) {
            const targetPosition = new THREE.Vector3(0, 6, 0);
            const offset = camera.position.clone().sub(targetPosition);
            offset.multiplyScalar(factor);
            
            const distance = offset.length();
            if (distance < 3) offset.setLength(3);
            if (distance > 12) offset.setLength(12);
            
            camera.position.copy(targetPosition).add(offset);
            camera.lookAt(targetPosition);
            
            updateCameraInfo();
        }

        // Color functions
        function generateColorPalette() {
            const paletteContainer = document.getElementById('color-palette');
            paletteContainer.innerHTML = '';
            
            commonColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.width = '30px';
                swatch.style.height = '30px';
                swatch.style.backgroundColor = color;
                swatch.style.border = '2px solid #8b4513';
                swatch.style.borderRadius = '3px';
                swatch.style.cursor = 'pointer';
                swatch.style.transition = 'transform 0.2s';
                
                swatch.addEventListener('click', () => {
                    currentColor = color;
                    document.getElementById('color-picker').value = color;
                    document.getElementById('color-code-input').value = color;
                    updateStatus(`Color selected: ${color}`);
                });
                
                swatch.addEventListener('mouseenter', () => {
                    swatch.style.transform = 'scale(1.1)';
                });
                
                swatch.addEventListener('mouseleave', () => {
                    swatch.style.transform = 'scale(1.0)';
                });
                
                paletteContainer.appendChild(swatch);
            });
        }

        function applyColorCode() {
            const colorInput = document.getElementById('color-code-input');
            let colorCode = colorInput.value.trim();
            
            // Validate and normalize color code
            if (!colorCode.startsWith('#')) {
                colorCode = '#' + colorCode;
            }
            
            // Basic validation
            if (/^#[0-9A-F]{6}$/i.test(colorCode)) {
                currentColor = colorCode.toLowerCase();
                document.getElementById('color-picker').value = currentColor;
                updateStatus(`Color applied: ${currentColor}`);
            } else {
                updateStatus('Invalid color code! Use format: #RRGGBB');
                colorInput.value = currentColor;
            }
        }

        function fillRect(layer, x, y, w, h, color) {
            const rgb = hexToRgb(color);
            const data = layer === 'body' ? skinData.body : skinData.outer;
            
            for (let py = y; py < y + h; py++) {
                for (let px = x; px < x + w; px++) {
                    if (px >= 0 && px < 64 && py >= 0 && py < 64) {
                        const index = (py * 64 + px) * 4;
                        data[index] = rgb.r;
                        data[index + 1] = rgb.g;
                        data[index + 2] = rgb.b;
                        data[index + 3] = 255;
                    }
                }
            }
        }

        function setPixel(layer, x, y, color) {
            const rgb = hexToRgb(color);
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (y * 64 + x) * 4;
            
            data[index] = rgb.r;
            data[index + 1] = rgb.g;
            data[index + 2] = rgb.b;
            data[index + 3] = 255;
        }

        // Undo/Redo functions
        function saveUndoState() {
            const state = {
                body: new Uint8ClampedArray(skinData.body),
                outer: new Uint8ClampedArray(skinData.outer)
            };
            
            undoStack.push(state);
            
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            redoStack = [];
        }

        function undoAction() {
            if (undoStack.length === 0) {
                updateStatus('Nothing to undo');
                return;
            }
            
            const currentState = {
                body: new Uint8ClampedArray(skinData.body),
                outer: new Uint8ClampedArray(skinData.outer)
            };
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            skinData.body.set(previousState.body);
            skinData.outer.set(previousState.outer);
            
            updateSkinTextures();
            updateStatus('Undo applied');
        }

        function redoAction() {
            if (redoStack.length === 0) {
                updateStatus('Nothing to redo');
                return;
            }
            
            saveUndoState();
            undoStack.pop();
            
            const redoState = redoStack.pop();
            skinData.body.set(redoState.body);
            skinData.outer.set(redoState.outer);
            
            updateSkinTextures();
            updateStatus('Redo applied');
        }

        function mirrorSkin() {
            saveUndoState();
            
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 0; y < 64; y++) {
                for (let x = 0; x < 32; x++) {
                    const leftIndex = (y * 64 + x) * 4;
                    const rightIndex = (y * 64 + (63 - x)) * 4;
                    
                    data[rightIndex] = tempData[leftIndex];
                    data[rightIndex + 1] = tempData[leftIndex + 1];
                    data[rightIndex + 2] = tempData[leftIndex + 2];
                    data[rightIndex + 3] = tempData[leftIndex + 3];
                }
            }
            
            updateSkinTextures();
            updateStatus('Skin mirrored');
        }

        function flipSkin() {
            saveUndoState();
            
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 0; y < 32; y++) {
                for (let x = 0; x < 64; x++) {
                    const topIndex = (y * 64 + x) * 4;
                    const bottomIndex = ((63 - y) * 64 + x) * 4;
                    
                    data[bottomIndex] = tempData[topIndex];
                    data[bottomIndex + 1] = tempData[topIndex + 1];
                    data[bottomIndex + 2] = tempData[topIndex + 2];
                    data[bottomIndex + 3] = tempData[topIndex + 3];
                    
                    data[topIndex] = tempData[bottomIndex];
                    data[topIndex + 1] = tempData[bottomIndex + 1];
                    data[topIndex + 2] = tempData[bottomIndex + 2];
                    data[topIndex + 3] = tempData[bottomIndex + 3];
                }
            }
            
            updateSkinTextures();
            updateStatus('Skin flipped');
        }

        // File operations
        function exportSkin() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const bodyImageData = new ImageData(skinData.body, 64, 64);
            const outerImageData = new ImageData(skinData.outer, 64, 64);
            
            ctx.putImageData(bodyImageData, 0, 0);
            ctx.putImageData(outerImageData, 0, 0);
            
            const link = document.createElement('a');
            link.download = 'minecraft_skin_3d.png';
            link.href = canvas.toDataURL();
            link.click();
            
            updateStatus('3D skin exported successfully!');
        }

        function importSkin(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(img, 0, 0, 64, 64);
                const imageData = ctx.getImageData(0, 0, 64, 64);
                
                skinData.body.set(imageData.data);
                skinData.outer.fill(0);
                
                updateSkinTextures();
                updateStatus(`3D skin imported: ${file.name}`);
            };
            
            img.src = URL.createObjectURL(file);
            e.target.value = '';
        }

        function newSkin() {
            if (confirm('Create a new skin? This will clear your current work.')) {
                initSkinData();
                updateSkinTextures();
                updateStatus('New empty 3D skin created');
            }
        }

        function clearSkin() {
            if (confirm('Clear the current editing layer?')) {
                const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
                data.fill(0); // Clear to transparent
                
                updateSkinTextures();
                updateStatus(`${currentEditingLayer} layer cleared`);
            }
        }

        function updateCameraInfo() {
            const targetPosition = new THREE.Vector3(0, 6, 0);
            const distance = Math.round(camera.position.distanceTo(targetPosition) * 10) / 10;
            const zoom = Math.round((4 / distance) * 100);
            document.getElementById('camera-info').textContent = `Camera: ${isEditMode ? 'Edit' : 'View'} | Zoom: ${zoom}%`;
        }

        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
            
            // Update tool name mapping
            const toolNames = {
                'pen': 'Pen',
                'brush': 'Brush', 
                'eyedropper': 'Picker',
                'rotate': 'Rotate'
            };
            
            document.getElementById('pixel-info').textContent = `Editing: ${currentEditingLayer === 'body' ? 'Body' : 'Outer'} Layer | Tool: ${toolNames[currentTool]}`;
        }

        // Utility functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        console.log('🎮 3D Minecraft Skin Editor with single voxel painting loaded successfully!');
    </script>



</body></html>