<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com https://text.pollinations.ai;
        connect-src 'self' https://text.pollinations.ai https://image.pollinations.ai;
        frame-src 'self' https://www.youtube.com https://trytako.com;
        child-src 'self';
        manifest-src 'self';
        worker-src 'self';
        upgrade-insecure-requests;
        block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft 3D Skin Editor</title>
    <link rel="icon" type="image/x-icon" href="icon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #6d9dc5 0%, #8fbc8f 100%);
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-height: 100vh;
        }

        .toolbar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 15px 20px;
            border-bottom: 3px solid #8b4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 10;
            flex-shrink: 0;
        }
        
        .title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .toolbar h1 {
            font-size: 20px;
            color: #ffffff;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
        }

        .minecraft-decoration {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .minecraft-block {
            width: 20px;
            height: 20px;
            border: 2px solid #000;
            position: relative;
            image-rendering: pixelated;
        }

        .block-dirt {
            background: linear-gradient(45deg, #8b4513 25%, #a0522d 25%, #a0522d 50%, #8b4513 50%, #8b4513 75%, #a0522d 75%);
            background-size: 4px 4px;
        }

        .block-grass {
            background: linear-gradient(to bottom, #9acd32 0%, #9acd32 30%, #8b4513 30%, #8b4513 70%, #a0522d 70%);
        }

        .block-stone {
            background: linear-gradient(45deg, #696969 25%, #808080 25%, #808080 50%, #696969 50%, #696969 75%, #808080 75%);
            background-size: 3px 3px;
        }

        .social-links {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 140px;
            gap: 6px;
            color: #1da1f2;
            text-decoration: none;
            font-size: 10px;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            border: 2px solid #1da1f2;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            white-space: nowrap;
        }

        .social-link:hover {
            background: #1da1f2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .social-icon {
            width: 12px;
            height: 12px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .toolbar-row:last-child {
            margin-bottom: 0;
        }

        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 6px;
            border: 2px solid #8b4513;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.5), 0 2px 4px rgba(0,0,0,0.2);
        }

        .tool-group-label {
            font-size: 11px;
            color: #4a4a4a;
            font-weight: 700;
            margin-right: 5px;
            text-transform: uppercase;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .tool-btn {
            padding: 8px 12px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .tool-btn.export {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .tool-btn.import {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            border-color: #e65100;
        }

        .tool-btn.clear {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #b71c1c;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
        }

        .ai-generator {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .ai-input {
            flex: 1;
            min-width: 200px;
            border: 2px solid #8b4513;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .ai-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 0 0 3px rgba(76, 175, 80, 0.2);
        }

        .ai-generate-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            display: flex;
            width: 240px;
            line-height: 1.5;
            color: white;
            border: 2px solid #e65100;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: nowrap;
        }

        .ai-generate-btn:hover {
            background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .ai-generate-btn:disabled {
            background: linear-gradient(135deg, #cccccc 0%, #aaaaaa 100%);
            border-color: #999999;
            cursor: not-allowed;
            transform: none;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: 2px solid #8b4513;
            border-radius: 4px;
            cursor: pointer;
            background: white;
        }

        .main-content {
            flex: 1;
            display: flex;
            background: linear-gradient(45deg, #e8f4f8 25%, #f0f8ff 25%, #f0f8ff 50%, #e8f4f8 50%, #e8f4f8 75%, #f0f8ff 75%);
            background-size: 20px 20px;
            border-left: 3px solid #8b4513;
            border-right: 3px solid #8b4513;
            min-height: 0;
            overflow: hidden;
        }

        .left-panel {
            width: 320px;
            padding: 20px;
            background: rgba(255,255,255,0.9);
            border-right: 3px solid #8b4513;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }

        .center-panel {
            flex: 1;
            padding: 20px;
            background: rgba(240,248,255,0.9);
            overflow: hidden;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .right-panel {
            width: 300px;
            padding: 20px;
            background: rgba(255,255,255,0.9);
            border-left: 3px solid #8b4513;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #4a4a4a;
            margin-bottom: 20px;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .viewer-container {
            position: relative;
            width: 100%;
            height: 100%;
            border: 3px solid #8b4513;
            border-radius: 6px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        }

        .skin-preview {
            width: 100%;
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #skinViewer {
            width: 100%;
            height: 100%;
            border-radius: 3px;
            cursor: crosshair;
        }

        .controls {
            width: 100%;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
        }

        .control-btn {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #8b4513;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #4a4a4a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: 'Courier New', monospace;
            text-align: center;
            min-width: 50px;
            height: 40px;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #e0e0e0 0%, #d0d0d0 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .layer-controls {
            background: rgba(255,255,255,0.7);
            border: 3px solid #8b4513;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .layer-toggle-btn {
            padding: 6px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            margin-right: 8px;
            margin-bottom: 8px;
            flex: 1;
            text-align: center;
        }

        .layer-toggle-btn.visible {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .layer-toggle-btn.editing {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
            border-width: 3px;
        }

        .layer-toggle-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .layer-toggle-btn.visible:hover {
            background: linear-gradient(135deg, #45a049 0%, #388e3c 100%);
        }

        .layer-toggle-btn.editing:hover {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        }

        .layer-row {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .body-parts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
        }

        .body-part-btn {
            padding: 12px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            text-align: center;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .body-part-btn.hidden {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border-color: #b71c1c;
        }

        .body-part-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .body-part-btn.hidden:hover {
            background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%);
        }

        .action-btn {
            padding: 6px 10px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            margin-right: 6px;
            margin-bottom: 6px;
            min-width: 70px;
            flex: 1;
        }

        .action-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .action-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .grid-tool-btn {
            padding: 10px 8px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
            color: #2a2a2a;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            text-align: center;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-tool-btn:hover {
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .grid-tool-btn.active {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0D47A1;
        }

        .grid-tool-btn.active:hover {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        }

        .hidden-file-input {
            display: none;
        }

        .status-bar {
            background: linear-gradient(135deg, #4a4a4a 0%, #2d2d2d 100%);
            padding: 12px 20px;
            font-size: 12px;
            color: #ffffff;
            border-top: 3px solid #8b4513;
            font-family: 'Courier New', monospace;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            z-index: 10;
            min-height: 50px;
            flex-shrink: 0;
            border-left: 3px solid #8b4513;
            border-right: 3px solid #8b4513;
            border-bottom: 3px solid #8b4513;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .edit-mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
        }

        .color-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .color-code-input {
            width: 80px;
            border: 2px solid #8b4513;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            background: white;
        }

        .color-apply-btn {
            padding: 6px 10px;
            border: 2px solid #8b4513;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }

        .color-apply-btn:hover {
            background: linear-gradient(135deg, #45a049 0%, #388e3c 100%);
            transform: translateY(-1px);
        }

        @media (max-width: 1200px) {
            .left-panel, .right-panel {
                width: 250px;
            }
            
            .social-link {
                min-width: 120px;
                font-size: 9px;
                padding: 4px 8px;
            }
        }

        @media (max-width: 768px) {
            .title-bar {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .social-links {
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100%;
                height: auto;
                min-height: 200px;
            }
            
            .center-panel {
                width: 100%;
                min-height: 400px;
            }

            .layer-row {
                flex-direction: column;
                gap: 8px;
            }

            .tools-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="toolbar">
            <div class="title-bar">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <h1>🎨 Minecraft 3D Skin Editor</h1>
                    <div class="minecraft-decoration">
                        <div class="minecraft-block block-grass"></div>
                        <div class="minecraft-block block-dirt"></div>
                        <div class="minecraft-block block-stone"></div>
                    </div>
                </div>
                <div class="social-links">
                    <a href="https://discord.gg/RKjspnTBmb" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M19.952,5.672c-1.904-1.531-4.916-1.79-5.044-1.801c-0.201-0.017-0.392,0.097-0.474,0.281 c-0.006,0.012-0.072,0.163-0.145,0.398c1.259,0.212,2.806,0.64,4.206,1.509c0.224,0.139,0.293,0.434,0.154,0.659 c-0.09,0.146-0.247,0.226-0.407,0.226c-0.086,0-0.173-0.023-0.252-0.072C15.584,5.38,12.578,5.305,12,5.305S8.415,5.38,6.011,6.872 c-0.225,0.14-0.519,0.07-0.659-0.154c-0.14-0.225-0.07-0.519,0.154-0.659c1.4-0.868,2.946-1.297,4.206-1.509 c-0.074-0.236-0.14-0.386-0.145-0.398C9.484,3.968,9.294,3.852,9.092,3.872c-0.127,0.01-3.139,0.269-5.069,1.822 C3.015,6.625,1,12.073,1,16.783c0,0.083,0.022,0.165,0.063,0.237c1.391,2.443,5.185,3.083,6.05,3.111c0.005,0,0.01,0,0.015,0 c0.153,0,0.297-0.073,0.387-0.197l0.875-1.202c-2.359-0.61-3.564-1.645-3.634-1.706c-0.198-0.175-0.217-0.477-0.042-0.675 c0.175-0.198,0.476-0.217,0.674-0.043c0.029,0.026,2.248,1.909,6.612,1.909c4.372,0,6.591-1.891,6.613-1.91 c0.198-0.172,0.5-0.154,0.674,0.045c0.174,0.198,0.155,0.499-0.042,0.673c-0.07,0.062-1.275,1.096-3.634,1.706l0.875,1.202 c0.09,0.124,0.234,0.197,0.387,0.197c0.005,0,0.01,0,0.015,0c0.865-0.027,4.659-0.667,6.05-3.111 C22.978,16.947,23,16.866,23,16.783C23,12.073,20.985,6.625,19.952,5.672z M8.891,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913s1.674,0.857,1.674,1.913S9.816,14.87,8.891,14.87z M15.109,14.87c-0.924,0-1.674-0.857-1.674-1.913 s0.749-1.913,1.674-1.913c0.924,0,1.674,0.857,1.674,1.913S16.033,14.87,15.109,14.87z"></path>
                        </svg>
                        Discord Server
                    </a>
                    <a href="https://github.com/aeromechanic000/minecraft-ai-oc-creator" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path>
                        </svg>
                        GitHub Repository 
                    </a>
                    <a href="https://x.com/aeromechan71402" target="_blank" rel="noopener noreferrer" class="social-link">
                        <svg class="social-icon" viewBox="0 0 24 24">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path>
                        </svg>
                        @aeromechan71402
                    </a>
                </div>
            </div>
            
            <div class="toolbar-row">
                <div class="tool-group">
                    <span class="tool-group-label">📂 File</span>
                    <input type="file" id="import-skin" accept=".png" class="hidden-file-input">
                    <button onclick="document.getElementById('import-skin').click()" class="tool-btn import">Import PNG</button>
                    <button onclick="exportSkin()" class="tool-btn export">Export PNG</button>
                    <button onclick="newSkin()" class="tool-btn">New Steve</button>
                    <button onclick="clearSkin()" class="tool-btn clear">Clear</button>
                </div>

                <div class="ai-generator">
                    <input type="text" class="ai-input" id="ai-input" placeholder="Describe body modifications (e.g., 'Add red stripes to the shirt', 'blue jeans', 'leather boots')">
                    <button id="ai-generate-btn" class="ai-generate-btn" onclick="generateAISkin()">
                        <span id="ai-btn-text">🤖 Generate Modifications</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">📋 Display Options</div>
                    <div class="layer-row">
                        <button id="layer-body" class="layer-toggle-btn visible" onclick="toggleLayerVisibility('body')">Body</button>
                        <button id="layer-outer" class="layer-toggle-btn" onclick="toggleLayerVisibility('outer')">Outer</button>
                        <button id="pixel-grid-btn" class="layer-toggle-btn visible" onclick="togglePixelGrid()">Grid</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">👤 Body Parts</div>
                    <div class="body-parts-grid">
                        <button class="body-part-btn" id="part-head" onclick="toggleBodyPart('head')">👤 Head</button>
                        <button class="body-part-btn" id="part-body" onclick="toggleBodyPart('body')">🎽 Body</button>
                        <button class="body-part-btn" id="part-leftarm" onclick="toggleBodyPart('leftarm')">🤳 L.Arm</button>
                        <button class="body-part-btn" id="part-rightarm" onclick="toggleBodyPart('rightarm')">💪 R.Arm</button>
                        <button class="body-part-btn" id="part-leftleg" onclick="toggleBodyPart('leftleg')">🦵 L.Leg</button>
                        <button class="body-part-btn" id="part-rightleg" onclick="toggleBodyPart('rightleg')">🏃 R.Leg</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🔧 Actions</div>
                    <div class="action-row">
                        <button onclick="undoAction()" class="action-btn">↶ Undo</button>
                        <button onclick="redoAction()" class="action-btn">↷ Redo</button>
                    </div>
                    <div class="action-row">
                        <button onclick="mirrorSkin()" class="action-btn">🪞 Mirror</button>
                        <button onclick="flipSkin()" class="action-btn">🔄 Flip</button>
                    </div>
                </div>
            </div>
            
            <div class="center-panel">
                <div class="viewer-container">
                    <div class="edit-mode-indicator" id="edit-mode-indicator">Editing: Body Layer</div>
                    <div class="skin-preview">
                        <canvas id="skinViewer"></canvas>
                    </div>
                    <div class="controls">
                        <button id="resetView" class="control-btn">🔄 Reset View</button>
                        <button id="toggleMode" class="control-btn">🔄 Toggle Mode</button>
                        <button id="zoomIn" class="control-btn">🔍 Zoom+</button>
                        <button id="zoomOut" class="control-btn">🔍 Zoom-</button>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🎯 Common Colors</div>
                    <div id="color-palette" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-bottom: 15px;">
                        <!-- Color swatches will be generated here -->
                    </div>
                    
                    <div class="color-input-group">
                        <input type="text" id="color-code-input" class="color-code-input" placeholder="#8B4513" value="#8B4513">
                        <button onclick="applyColorCode()" class="color-apply-btn">Apply</button>
                    </div>
                </div>

                <div class="layer-controls">
                    <div class="panel-title" style="font-size: 16px; margin-bottom: 15px;">🎨 3D Tools</div>
                    <div class="tools-grid">
                        <button id="tool-pen" class="grid-tool-btn active" onclick="setTool('pen')">✏️ Pen</button>
                        <button id="tool-brush" class="grid-tool-btn" onclick="setTool('brush')">🖌️ Brush</button>
                        <button id="tool-eyedropper" class="grid-tool-btn" onclick="setTool('eyedropper')">💧 Picker</button>
                        <button id="tool-rotate" class="grid-tool-btn" onclick="setTool('rotate')">🔄 Rotate</button>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label style="font-size: 12px; font-weight: bold; color: #4a4a4a; margin-bottom: 8px; display: block;">Current Color:</label>
                        <input type="color" id="color-picker" class="color-picker" value="#8B4513" style="width: 100%;">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-info">
                <span id="status-text">🎨 3D Paint Mode - Click on the model to paint pixels!</span>
                <span id="pixel-info">Editing: Body Layer | Tool: Pen</span>
                <span id="camera-info">Camera: Free | Zoom: 100%</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let skinModel, gridOverlay;
        let currentTool = 'pen';
        let currentEditingLayer = 'body';
        let currentColor = '#8B4513';
        let showPixelGrid = true;
        let isEditMode = true;

        // Layer visibility states
        let layerVisibility = {
            body: true,
            outer: false
        };

        // Interaction variables
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let hoveredFace = null;
        let isDragging = false;
        let isRotating = false;
        let dragStart = new THREE.Vector2();
        let lastPaintedVoxel = null;

        // Skin data
        let skinData = {
            body: new Uint8ClampedArray(64 * 64 * 4),
            outer: new Uint8ClampedArray(64 * 64 * 4)
        };

        // Store original head data to preserve it
        let originalHeadData = {
            body: null,
            outer: null
        };

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;

        // Body parts visibility
        let bodyPartsVisible = {
            head: true,
            body: true,
            leftarm: true,
            rightarm: true,
            leftleg: true,
            rightleg: true
        };

        // Common colors palette
        let commonColors = [
            '#8B4513', '#F4A460', '#DEB887', '#D2691E', '#654321', '#A0522D',
            '#FF0000', '#FF4500', '#FF6347', '#DC143C', '#8B0000', '#B22222',
            '#0000FF', '#4169E1', '#1E90FF', '#87CEEB', '#000080', '#191970',
            '#228B22', '#32CD32', '#00FF00', '#ADFF2F', '#006400', '#9ACD32',
            '#800080', '#9932CC', '#DA70D6', '#FF69B4', '#4B0082', '#8A2BE2',
            '#FFFF00', '#FFD700', '#FFA500', '#FF8C00', '#DAA520', '#B8860B',
            '#000000', '#2F2F2F', '#696969', '#808080', '#C0C0C0', '#FFFFFF'
        ];

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initScene();
            initSkinData();
            setupEventListeners();
            generateColorPalette();
            createSkinModel();
            createGridOverlay();
            updateLayerDisplay();
            updateLayerButtons();
            updatePixelGridButton();
            updateStatus('🎨 3D Skin Editor loaded - Loading Steve skin...');
        });

        // UPDATED: AI Generation Function - Now using JSON-based approach
        async function generateAISkin() {
            const prompt = document.getElementById('ai-input').value.trim();
            if (!prompt) {
                updateStatus('Please enter a description for AI generation');
                return;
            }

            const generateBtn = document.getElementById('ai-generate-btn');
            const btnText = document.getElementById('ai-btn-text');
            
            // Disable button and show loading state
            generateBtn.disabled = true;
            btnText.textContent = '🤖 Generating...';
            updateStatus('🤖 AI is generating skin data...');

            try {
                // Save current state for undo
                saveUndoState();
                
                // Preserve original head data before any modifications
                if (!originalHeadData.body) {
                    saveOriginalHeadData();
                }

                // Create enhanced prompt for JSON generation

                const jsonPrompt = `Generate a JSON object for Minecraft skin modifications based on this description: "${prompt}". 

The JSON should contain specific color modifications for body parts (excluding head) with separate body and outer layers. Return ONLY valid JSON in this exact format:

{
  "body_layer": {
    "torso": {
      "color": "#hexcolor",
      "pattern": "solid|stripes|checkered|dots"
    },
    "arms": {
      "color": "#hexcolor", 
      "pattern": "solid|stripes|checkered|dots"
    },
    "legs": {
      "color": "#hexcolor",
      "pattern": "solid|stripes|checkered|dots"
    }
  },
  "outer_layer": {
    "torso": {
      "color": "#hexcolor",
      "pattern": "solid|stripes|checkered|dots",
      "enabled": true|false
    },
    "arms": {
      "color": "#hexcolor",
      "pattern": "solid|stripes|checkered|dots", 
      "enabled": true|false
    },
    "legs": {
      "color": "#hexcolor",
      "pattern": "solid|stripes|checkered|dots",
      "enabled": true|false
    }
  },
  "style": {
    "theme": "casual|formal|fantasy|superhero|medieval|modern",
    "skin_tone": "#hexcolor"
  }
}

Generate realistic hex colors that match the description. No additional text, just the JSON.`;

                // Call Pollinations AI text API to get JSON data
                const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(jsonPrompt)}`);
                const aiText = await response.text();
                
                // Extract JSON from the response
                let skinConfig;
                try {
                    // Try to parse the response as JSON
                    const jsonMatch = aiText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        skinConfig = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No valid JSON found in response');
                    }
                } catch (parseError) {
                    console.log('Direct JSON parse failed, attempting fallback generation...');
                    // Fallback: Generate a config based on the prompt keywords
                    skinConfig = generateFallbackConfig(prompt);
                }
                
                // Apply the skin configuration
                applySkinConfiguration(skinConfig);
                
                // Restore the original head data
                restoreOriginalHeadData();
                
                // Update the 3D model
                updateSkinTextures();
                updateStatus(`🎨 AI skin generated successfully! Applied: ${JSON.stringify(skinConfig.style?.theme || 'custom modifications')}`);
                
            } catch (error) {
                console.error('Error in AI generation:', error);
                updateStatus('❌ Error generating AI skin. Using fallback generation...');
                
                // Fallback generation
                try {
                    const fallbackConfig = generateFallbackConfig(prompt);
                    applySkinConfiguration(fallbackConfig);
                    restoreOriginalHeadData();
                    updateSkinTextures();
                    updateStatus('🎨 Fallback skin generated successfully!');
                } catch (fallbackError) {
                    updateStatus('❌ Error in skin generation');
                    undoAction(); // Revert changes
                }
            } finally {
                // Re-enable button
                generateBtn.disabled = false;
                btnText.textContent = '🤖 Generate Body Modifications';
            }
        }

        // NEW: Generate fallback configuration based on prompt keywords
        function generateFallbackConfig(prompt) {
            const promptLower = prompt.toLowerCase();
            
            // Color extraction based on keywords
            const colorMap = {
                'red': '#DC143C', 'blue': '#1E90FF', 'green': '#32CD32', 'yellow': '#FFD700',
                'orange': '#FF8C00', 'purple': '#9932CC', 'pink': '#FF69B4', 'brown': '#8B4513',
                'black': '#2F2F2F', 'white': '#F0F0F0', 'gray': '#808080', 'grey': '#808080',
                'dark': '#404040', 'light': '#E0E0E0', 'gold': '#DAA520', 'silver': '#C0C0C0'
            };
            
            // Extract colors mentioned in prompt
            const mentionedColors = [];
            for (const [keyword, color] of Object.entries(colorMap)) {
                if (promptLower.includes(keyword)) {
                    mentionedColors.push(color);
                }
            }
            
            // Default colors if none mentioned
            if (mentionedColors.length === 0) {
                mentionedColors.push('#4169E1', '#32CD32', '#FF8C00');
            }
            
            // Determine theme based on keywords
            let theme = 'casual';
            if (promptLower.includes('knight') || promptLower.includes('medieval') || promptLower.includes('armor')) {
                theme = 'medieval';
            } else if (promptLower.includes('suit') || promptLower.includes('formal') || promptLower.includes('tie')) {
                theme = 'formal';
            } else if (promptLower.includes('hero') || promptLower.includes('super') || promptLower.includes('cape')) {
                theme = 'superhero';
            } else if (promptLower.includes('magic') || promptLower.includes('wizard') || promptLower.includes('fantasy')) {
                theme = 'fantasy';
            }
            
            // Generate configuration
            const primaryColor = mentionedColors[0] || '#4169E1';
            const secondaryColor = mentionedColors[1] || '#32CD32';
            const accentColor = mentionedColors[2] || '#FF8C00';
            
            return {
                body_layer: {
                    torso: {
                        color: primaryColor,
                        pattern: promptLower.includes('stripe') ? 'stripes' : 
                                promptLower.includes('check') ? 'checkered' : 'solid'
                    },
                    arms: {
                        color: primaryColor,
                        pattern: 'solid'
                    },
                    legs: {
                        color: secondaryColor,
                        pattern: 'solid'
                    }
                },
                outer_layer: {
                    torso: {
                        color: accentColor,
                        pattern: 'solid',
                        enabled: true
                    },
                    arms: {
                        color: accentColor,
                        pattern: 'solid',
                        enabled: true
                    },
                    legs: {
                        color: '#2F2F2F',
                        pattern: 'solid',
                        enabled: false
                    }
                },
                style: {
                    theme: theme,
                    skin_tone: '#F4A460'
                }
            };
        }

        // NEW: Apply skin configuration from JSON data

        function applySkinConfiguration(config) {
            // Apply body layer modifications
            if (config.body_layer) {
                if (config.body_layer.torso) {
                    applyColorToBodyPart('body', 'torso', config.body_layer.torso.color, config.body_layer.torso.pattern);
                }
                if (config.body_layer.arms) {
                    applyColorToBodyPart('body', 'arms', config.body_layer.arms.color, config.body_layer.arms.pattern);
                }
                if (config.body_layer.legs) {
                    applyColorToBodyPart('body', 'legs', config.body_layer.legs.color, config.body_layer.legs.pattern);
                }
            }
            
            // Apply outer layer modifications
            if (config.outer_layer) {
                if (config.outer_layer.torso && config.outer_layer.torso.enabled) {
                    applyColorToBodyPart('outer', 'torso', config.outer_layer.torso.color, config.outer_layer.torso.pattern);
                }
                if (config.outer_layer.arms && config.outer_layer.arms.enabled) {
                    applyColorToBodyPart('outer', 'arms', config.outer_layer.arms.color, config.outer_layer.arms.pattern);
                }
                if (config.outer_layer.legs && config.outer_layer.legs.enabled) {
                    applyColorToBodyPart('outer', 'legs', config.outer_layer.legs.color, config.outer_layer.legs.pattern);
                }
            }
        }

        // NEW: Apply color to specific body parts with patterns
        function applyColorToBodyPart(layer, partType, color, pattern) {
            const rgb = hexToRgb(color);
            const data = layer === 'body' ? skinData.body : skinData.outer;
            
            // Get body part areas based on type
            const areas = getBodyPartAreas(partType);
            
            areas.forEach(area => {
                applyColorWithPattern(data, area, rgb, pattern);
            });
        }

        // NEW: Get texture areas for different body part types
        function getBodyPartAreas(partType) {
            switch (partType) {
                case 'torso':
                    return [
                        { x: 20, y: 20, w: 8, h: 12 }, // Body front
                        { x: 16, y: 20, w: 4, h: 12 }, // Body right
                        { x: 28, y: 20, w: 4, h: 12 }, // Body left
                        { x: 32, y: 20, w: 8, h: 12 }, // Body back
                        { x: 20, y: 16, w: 8, h: 4 },  // Body top
                        { x: 28, y: 16, w: 8, h: 4 }   // Body bottom
                    ];
                case 'arms':
                    return [
                        // Right arm
                        { x: 44, y: 20, w: 4, h: 12 }, { x: 40, y: 20, w: 4, h: 12 },
                        { x: 48, y: 20, w: 4, h: 12 }, { x: 52, y: 20, w: 4, h: 12 },
                        { x: 44, y: 16, w: 4, h: 4 },  { x: 48, y: 16, w: 4, h: 4 },
                        // Left arm
                        { x: 36, y: 52, w: 4, h: 12 }, { x: 32, y: 52, w: 4, h: 12 },
                        { x: 40, y: 52, w: 4, h: 12 }, { x: 44, y: 52, w: 4, h: 12 },
                        { x: 36, y: 48, w: 4, h: 4 },  { x: 40, y: 48, w: 4, h: 4 }
                    ];
                case 'legs':
                    return [
                        // Right leg
                        { x: 4, y: 20, w: 4, h: 8 },   { x: 0, y: 20, w: 4, h: 8 },
                        { x: 8, y: 20, w: 4, h: 8 },   { x: 12, y: 20, w: 4, h: 8 },
                        // Left leg
                        { x: 20, y: 52, w: 4, h: 8 },  { x: 16, y: 52, w: 4, h: 8 },
                        { x: 24, y: 52, w: 4, h: 8 },  { x: 28, y: 52, w: 4, h: 8 }
                    ];
                case 'feet':
                    return [
                        // Right leg bottom
                        { x: 4, y: 28, w: 4, h: 4 },   { x: 0, y: 28, w: 4, h: 4 },
                        { x: 8, y: 28, w: 4, h: 4 },   { x: 12, y: 28, w: 4, h: 4 },
                        // Left leg bottom
                        { x: 20, y: 60, w: 4, h: 4 },  { x: 16, y: 60, w: 4, h: 4 },
                        { x: 24, y: 60, w: 4, h: 4 },  { x: 28, y: 60, w: 4, h: 4 }
                    ];
                default:
                    return [];
            }
        }

        // NEW: Apply color with pattern to a specific area
        function applyColorWithPattern(data, area, rgb, pattern) {
            for (let y = 0; y < area.h; y++) {
                for (let x = 0; x < area.w; x++) {
                    const pixelX = area.x + x;
                    const pixelY = area.y + y;
                    
                    if (pixelX >= 0 && pixelX < 64 && pixelY >= 0 && pixelY < 64) {
                        const index = (pixelY * 64 + pixelX) * 4;
                        
                        // Apply pattern
                        const shouldColor = getPatternValue(x, y, pattern);
                        
                        if (shouldColor) {
                            // Add some variation for more natural look
                            const variation = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
                            
                            data[index] = Math.min(255, Math.max(0, rgb.r * variation));
                            data[index + 1] = Math.min(255, Math.max(0, rgb.g * variation));
                            data[index + 2] = Math.min(255, Math.max(0, rgb.b * variation));
                            data[index + 3] = 255;
                        }
                    }
                }
            }
        }

        // NEW: Get pattern value for specific pixel
        function getPatternValue(x, y, pattern) {
            switch (pattern) {
                case 'stripes':
                    return y % 2 === 0;
                case 'checkered':
                    return (x + y) % 2 === 0;
                case 'dots':
                    return (x % 3 === 1 && y % 3 === 1);
                case 'solid':
                default:
                    return true;
            }
        }

        // NEW: Apply outer layer effects for clothing
        function applyOuterLayerEffects(config) {
            // Apply outer layer effects for clothing depth
            if (config.body?.shirt_color) {
                const outerAreas = [
                    { x: 20, y: 36, w: 8, h: 12 }, // Body outer front
                    { x: 16, y: 36, w: 4, h: 12 }, // Body outer right
                    { x: 28, y: 36, w: 4, h: 12 }, // Body outer left
                    { x: 32, y: 36, w: 8, h: 12 }  // Body outer back
                ];
                
                const rgb = hexToRgb(config.body.shirt_color);
                // Make outer layer slightly darker for depth effect
                rgb.r = Math.max(0, rgb.r - 20);
                rgb.g = Math.max(0, rgb.g - 20);
                rgb.b = Math.max(0, rgb.b - 20);
                
                outerAreas.forEach(area => {
                    applyColorWithPattern(skinData.outer, area, rgb, config.body.shirt_pattern || 'solid');
                });
            }
        }

        function saveOriginalHeadData() {
            // Save head areas from both layers
            originalHeadData.body = new Uint8ClampedArray(64 * 64 * 4);
            originalHeadData.outer = new Uint8ClampedArray(64 * 64 * 4);
            
            originalHeadData.body.set(skinData.body);
            originalHeadData.outer.set(skinData.outer);
        }

        function restoreOriginalHeadData() {
            if (!originalHeadData.body) return;
            
            // Define head areas to restore
            const headAreas = [
                { x: 8, y: 8, w: 8, h: 8 },    // Head front
                { x: 0, y: 8, w: 8, h: 8 },    // Head right
                { x: 16, y: 8, w: 8, h: 8 },   // Head left  
                { x: 24, y: 8, w: 8, h: 8 },   // Head back
                { x: 8, y: 0, w: 8, h: 8 },    // Head top
                { x: 16, y: 0, w: 8, h: 8 },   // Head bottom
                
                // Head outer layer
                { x: 40, y: 8, w: 8, h: 8 },   // Head outer front
                { x: 32, y: 8, w: 8, h: 8 },   // Head outer right
                { x: 48, y: 8, w: 8, h: 8 },   // Head outer left
                { x: 56, y: 8, w: 8, h: 8 },   // Head outer back
                { x: 40, y: 0, w: 8, h: 8 },   // Head outer top
                { x: 48, y: 0, w: 8, h: 8 }    // Head outer bottom
            ];
            
            // Restore head areas from original data
            headAreas.forEach(area => {
                copyPixelArea(originalHeadData.body, skinData.body, area.x, area.y, area.w, area.h, area.x, area.y);
                copyPixelArea(originalHeadData.outer, skinData.outer, area.x, area.y, area.w, area.h, area.x, area.y);
            });
        }

        function initScene() {
            const container = document.querySelector('.skin-preview');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 6, 5);
            camera.lookAt(0, 6, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('skinViewer'),
                antialias: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Setup camera controls
            setupCameraControls();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function setupCameraControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function onMouseDown(event) {
            event.preventDefault();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            dragStart.copy(mouse);
            isDragging = true;
            lastPaintedVoxel = null;
            
            // Right button (2) always rotates
            if (event.button === 2) {
                isRotating = true;
                return;
            }
            
            // Left button behavior
            if (event.button === 0) {
                if ((currentTool === 'pen' || currentTool === 'brush') && isEditMode) {
                    paintFace();
                } else if (currentTool === 'eyedropper' && isEditMode) {
                    pickColor();
                } else if (currentTool === 'rotate' || !isEditMode) {
                    isRotating = true;
                }
            }
        }

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycasting for hover effects (only in edit mode)
            if (isEditMode && !isRotating) {
                updateFaceHover();
            }
            
            if (isDragging) {
                if (isRotating) {
                    const deltaX = mouse.x - dragStart.x;
                    const deltaY = mouse.y - dragStart.y;
                    
                    // Rotate camera around target
                    const spherical = new THREE.Spherical();
                    const targetPosition = new THREE.Vector3(0, 6, 0);
                    const offset = camera.position.clone().sub(targetPosition);
                    spherical.setFromVector3(offset);
                    spherical.theta -= deltaX * 2;
                    spherical.phi += deltaY * 2;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical).add(targetPosition);
                    camera.lookAt(targetPosition);
                    
                    dragStart.copy(mouse);
                } else if ((currentTool === 'pen' || currentTool === 'brush') && isEditMode) {
                    paintFace();
                }
            }
        }

        function onMouseUp(event) {
            isDragging = false;
            isRotating = false;
            lastPaintedVoxel = null;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            const zoomSpeed = 0.1;
            const direction = event.deltaY > 0 ? 1 : -1;
            const targetPosition = new THREE.Vector3(0, 6, 0);
            
            const offset = camera.position.clone().sub(targetPosition);
            offset.multiplyScalar(1 + direction * zoomSpeed);
            
            // Limit zoom
            const distance = offset.length();
            if (distance < 3) offset.setLength(3);
            if (distance > 12) offset.setLength(12);
            
            camera.position.copy(targetPosition).add(offset);
            camera.lookAt(targetPosition);
            
            updateCameraInfo();
        }

        function updateFaceHover() {
            raycaster.setFromCamera(mouse, camera);
            
            if (skinModel) {
                const editingLayerMeshes = [];
                
                skinModel.children.forEach(layerGroup => {
                    if (layerGroup.visible && layerGroup.name === `${currentEditingLayer}_layer`) {
                        layerGroup.children.forEach(partGroup => {
                            if (partGroup.visible) {
                                partGroup.children.forEach(mesh => {
                                    if (mesh.visible && mesh.material.opacity > 0) {
                                        editingLayerMeshes.push(mesh);
                                    }
                                });
                            }
                        });
                    }
                });
                
                const intersects = raycaster.intersectObjects(editingLayerMeshes, false);
                
                // Clear previous hover
                if (hoveredFace) {
                    hoveredFace.material.emissive.setHex(0x000000);
                    hoveredFace = null;
                }
                
                // Hover the closest face from the current editing layer
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const face = intersect.object;
                    
                    if (face.userData && face.userData.layer === currentEditingLayer) {
                        hoveredFace = face;
                        face.material.emissive.setHex(0x404040);
                    }
                }
            }
        }

        function paintFace() {
            if (!hoveredFace || !hoveredFace.userData) return;
            
            const { voxelX, voxelY, voxelZ, layer, face: faceName } = hoveredFace.userData;
            
            // Only paint if it's the current editing layer
            if (layer !== currentEditingLayer) return;
            
            const voxelId = `${voxelX},${voxelY},${voxelZ},${layer},${faceName}`;
            
            if (lastPaintedVoxel === voxelId) return;
            
            if (lastPaintedVoxel === null) {
                saveUndoState();
            }
            
            lastPaintedVoxel = voxelId;
            
            // Get proper texture coordinates for this voxel and face
            const texCoords = getVoxelFaceTextureCoords(voxelX, voxelY, voxelZ, faceName);
            if (!texCoords) return;
            
            const { x: textureX, y: textureY } = texCoords;
            
            if (currentTool === 'pen') {
                paintPixelPen(textureX, textureY);
            } else if (currentTool === 'brush') {
                paintPixelBrush(textureX, textureY);
            }
            
            updateSkinTextures();
        }

        function pickColor() {
            if (!hoveredFace || !hoveredFace.userData) return;
            
            const { voxelX, voxelY, voxelZ, layer, face: faceName } = hoveredFace.userData;
            
            if (layer !== currentEditingLayer) return;
            
            const texCoords = getVoxelFaceTextureCoords(voxelX, voxelY, voxelZ, faceName);
            if (!texCoords) return;
            
            const { x: textureX, y: textureY } = texCoords;
            
            const color = getPixelColor(textureX, textureY, layer);
            
            currentColor = color;
            document.getElementById('color-picker').value = color;
            document.getElementById('color-code-input').value = color;
            updateStatus(`Color picked: ${color}`);
        }

        function initSkinData() {
            // Load default Steve skin from steve.png
            loadSteveSkin();
        }

        function loadSteveSkin() {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Draw the image to canvas and get pixel data
                ctx.drawImage(img, 0, 0, 64, 64);
                const imageData = ctx.getImageData(0, 0, 64, 64);
                const pixels = imageData.data;
                
                // Clear both layers first
                skinData.body.fill(0);
                skinData.outer.fill(0);
                
                // Extract body layer and outer layer from the steve skin
                extractSkinLayers(pixels);
                
                // Save original head data when loading Steve skin
                saveOriginalHeadData();
                
                // Enable body layer by default
                layerVisibility.body = true;
                layerVisibility.outer = false;
                currentEditingLayer = 'body';
                
                updateLayerButtons();
                updateLayerVisibility3D();
                updateSkinTextures();
                updateLayerDisplay();
                updateStatus('Steve skin loaded successfully - ready for editing!');
            };
            
            img.onerror = function() {
                // If steve.png doesn't exist, create empty skin
                updateStatus('steve.png not found - starting with empty skin');
                createEmptySkin();
            };
            
            // Try to load steve.png from the same directory
            img.src = './steve.png';
        }

        function createEmptySkin() {
            // Initialize both layers as completely transparent/empty
            for (let i = 0; i < skinData.body.length; i += 4) {
                skinData.body[i] = 0;        // R
                skinData.body[i + 1] = 0;    // G
                skinData.body[i + 2] = 0;    // B
                skinData.body[i + 3] = 0;    // A (transparent)
            }
            
            for (let i = 0; i < skinData.outer.length; i += 4) {
                skinData.outer[i] = 0;       // R
                skinData.outer[i + 1] = 0;   // G
                skinData.outer[i + 2] = 0;   // B
                skinData.outer[i + 3] = 0;   // A (transparent)
            }
            
            updateSkinTextures();
        }

        function paintPixelPen(x, y) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return;
            
            const rgb = hexToRgb(currentColor);
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            
            const index = (y * 64 + x) * 4;
            data[index] = rgb.r;
            data[index + 1] = rgb.g;
            data[index + 2] = rgb.b;
            data[index + 3] = 255;
        }

        function paintPixelBrush(x, y) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return;
            
            const rgb = hexToRgb(currentColor);
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            
            const brightnessShift = (Math.random() - 0.5) * 60;
            
            let newR = Math.round(rgb.r + brightnessShift);
            let newG = Math.round(rgb.g + brightnessShift);
            let newB = Math.round(rgb.b + brightnessShift);
            
            newR = Math.max(0, Math.min(255, newR));
            newG = Math.max(0, Math.min(255, newG));
            newB = Math.max(0, Math.min(255, newB));
            
            const index = (y * 64 + x) * 4;
            data[index] = newR;
            data[index + 1] = newG;
            data[index + 2] = newB;
            data[index + 3] = 255;
        }

        function getPixelColor(x, y, layer) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return '#000000';
            
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (y * 64 + x) * 4;
            
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            
            if (a === 0) return '#000000';
            
            return rgbToHex(r, g, b);
        }

        function createSkinModel() {
            skinModel = new THREE.Group();
            
            const bodyGroup = new THREE.Group();
            const outerGroup = new THREE.Group();
            
            createBodyPartSurfaces(bodyGroup, 'body', 1.0);
            createBodyPartSurfaces(outerGroup, 'outer', 1.1);
            
            bodyGroup.name = 'body_layer';
            outerGroup.name = 'outer_layer';
            
            skinModel.add(bodyGroup);
            skinModel.add(outerGroup);
            
            scene.add(skinModel);
        }

        function createBodyPartSurfaces(parentGroup, layer, scale) {
            // Head surfaces (8x8x8)
            const headGroup = createPartSurfaces('head', -4, 4, 50, 58, -4, 4, layer, scale);
            
            // Body surfaces (8x12x4)
            const bodyGroup = createPartSurfaces('body', -4, 4, 38, 50, -2, 2, layer, scale);
            
            // Right arm surfaces (4x12x4)
            const rightArmGroup = createPartSurfaces('rightarm', -7, -3, 38, 50, -2, 2, layer, scale);
            
            // Left arm surfaces (4x12x4)
            const leftArmGroup = createPartSurfaces('leftarm', 3, 7, 38, 50, -2, 2, layer, scale);
            
            // Right leg surfaces (4x12x4)
            const rightLegGroup = createPartSurfaces('rightleg', -4, 0, 26, 38, -2, 2, layer, scale);
            
            // Left leg surfaces (4x12x4)
            const leftLegGroup = createPartSurfaces('leftleg', 0, 4, 26, 38, -2, 2, layer, scale);
            
            parentGroup.add(headGroup);
            parentGroup.add(bodyGroup);
            parentGroup.add(rightArmGroup);
            parentGroup.add(leftArmGroup);
            parentGroup.add(rightLegGroup);
            parentGroup.add(leftLegGroup);
        }

        // FIXED: Proper outer layer positioning that covers the body layer
        function createPartSurfaces(partName, xMin, xMax, yMin, yMax, zMin, zMax, layer, scale) {
            const partGroup = new THREE.Group();
            partGroup.name = `${partName}_${layer}`;
            
            for (let x = xMin; x < xMax; x++) {
                for (let y = yMin; y < yMax; y++) {
                    for (let z = zMin; z < zMax; z++) {
                        if (isOnSurface(x, y, z, xMin, xMax, yMin, yMax, zMin, zMax)) {
                            createVoxelSurfaces(partGroup, x, y, z, xMin, xMax, yMin, yMax, zMin, zMax, scale, layer, partName);
                        }
                    }
                }
            }
            
            // FIXED: For outer layer, apply proper scaling and positioning
            if (layer === 'outer' && scale !== 1.0) {
                // Calculate the center of the body part for proper scaling origin
                const centerX = (xMin + xMax) / 2;
                const centerY = (yMin + yMax) / 2;
                const centerZ = (zMin + zMax) / 2;
                
                // Scale the entire part group uniformly from its center
                partGroup.scale.set(scale, scale, scale);
                
                // Position the scaled group so it surrounds the body layer perfectly
                // No additional offset needed - scaling from center already positions it correctly
                const bodyCenter = new THREE.Vector3(centerX * 0.125, centerY * 0.125, centerZ * 0.125);
                partGroup.position.copy(bodyCenter);
                
                // Apply inverse transform to compensate for scaling
                partGroup.position.multiplyScalar(1 - scale);
            }
            
            return partGroup;
        }

        function isOnSurface(x, y, z, xMin, xMax, yMin, yMax, zMin, zMax) {
            return (
                x === xMin || x === xMax - 1 ||
                y === yMin || y === yMax - 1 ||
                z === zMin || z === zMax - 1
            );
        }

        function createVoxelSurfaces(parentGroup, voxelX, voxelY, voxelZ, xMin, xMax, yMin, yMax, zMin, zMax, scale, layer, partName) {
            const voxelSize = 0.125;
            const faceGeometry = new THREE.PlaneGeometry(voxelSize, voxelSize);
            
            // Define faces with conditions for when they should be visible
            const faces = [
                { pos: [voxelSize/2, 0, 0], rot: [0, Math.PI/2, 0], name: 'right', condition: voxelX === xMax - 1 },
                { pos: [-voxelSize/2, 0, 0], rot: [0, -Math.PI/2, 0], name: 'left', condition: voxelX === xMin },
                { pos: [0, voxelSize/2, 0], rot: [-Math.PI/2, 0, 0], name: 'top', condition: voxelY === yMax - 1 },
                { pos: [0, -voxelSize/2, 0], rot: [Math.PI/2, 0, 0], name: 'bottom', condition: voxelY === yMin },
                { pos: [0, 0, voxelSize/2], rot: [0, 0, 0], name: 'front', condition: voxelZ === zMax - 1 },
                { pos: [0, 0, -voxelSize/2], rot: [0, Math.PI, 0], name: 'back', condition: voxelZ === zMin }
            ];
            
            faces.forEach(face => {
                // Only create faces that are actually on the surface
                if (!face.condition) return;
                
                const texCoords = getVoxelFaceTextureCoords(voxelX, voxelY, voxelZ, face.name, partName);
                if (!texCoords) return;
                
                const { x: textureX, y: textureY } = texCoords;
                
                const materialProps = getVoxelMaterial(textureX, textureY, layer);
                
                const material = new THREE.MeshLambertMaterial({
                    color: materialProps.color,
                    transparent: true,
                    opacity: materialProps.opacity,
                    side: THREE.DoubleSide
                });
                
                const faceMesh = new THREE.Mesh(faceGeometry, material);
                
                // Position faces normally - scaling happens at group level
                const baseX = (voxelX + 0.5) * 0.125;
                const baseY = (voxelY + 0.5) * 0.125;
                const baseZ = (voxelZ + 0.5) * 0.125;
                
                faceMesh.position.set(
                    baseX + face.pos[0],
                    baseY + face.pos[1],
                    baseZ + face.pos[2]
                );
                
                faceMesh.rotation.set(face.rot[0], face.rot[1], face.rot[2]);
                
                faceMesh.userData = {
                    textureX,
                    textureY,
                    layer,
                    partName,
                    voxelX,
                    voxelY,
                    voxelZ,
                    face: face.name
                };
                
                parentGroup.add(faceMesh);
            });
        }

        function getVoxelMaterial(textureX, textureY, layer) {
            const data = layer === 'body' ? skinData.body : skinData.outer;
            const index = (textureY * 64 + textureX) * 4;
            
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];
            
            if (a === 0) {
                if (layer === 'outer') {
                    return {
                        color: 0x000000,
                        opacity: 0.0
                    };
                } else {
                    return {
                        color: showPixelGrid ? 0x404040 : 0x202020,
                        opacity: showPixelGrid ? 0.2 : 0.0
                    };
                }
            }
            
            return {
                color: (r << 16) | (g << 8) | b,
                opacity: 1.0
            };
        }

        // FIXED: Complete texture coordinate mapping for all faces and body parts
        function getVoxelFaceTextureCoords(voxelX, voxelY, voxelZ, faceName, partName) {
            // Convert voxel coordinates to local coordinates within each body part
            let localX, localY, localZ;
            
            // Determine body part and convert to local coordinates
            if (voxelY >= 50 && voxelY <= 57) {
                // Head
                partName = 'head';
                localX = voxelX + 4; // -4 to 3 becomes 0 to 7
                localY = voxelY - 50; // 50 to 57 becomes 0 to 7
                localZ = voxelZ + 4; // -4 to 3 becomes 0 to 7
            } else if (voxelY >= 38 && voxelY <= 49) {
                if (voxelX >= -4 && voxelX <= 3) {
                    // Body
                    partName = 'body';
                    localX = voxelX + 4; // -4 to 3 becomes 0 to 7
                    localY = voxelY - 38; // 38 to 49 becomes 0 to 11
                    localZ = voxelZ + 2; // -2 to 1 becomes 0 to 3
                } else if (voxelX >= -7 && voxelX <= -4) {
                    // Right arm
                    partName = 'rightarm';
                    localX = voxelX + 7; // -7 to -4 becomes 0 to 3
                    localY = voxelY - 38; // 38 to 49 becomes 0 to 11
                    localZ = voxelZ + 2; // -2 to 1 becomes 0 to 3
                } else if (voxelX >= 4 && voxelX <= 7) {
                    // Left arm
                    partName = 'leftarm';
                    localX = voxelX - 4; // 4 to 7 becomes 0 to 3
                    localY = voxelY - 38; // 38 to 49 becomes 0 to 11
                    localZ = voxelZ + 2; // -2 to 1 becomes 0 to 3
                }
            } else if (voxelY >= 26 && voxelY <= 37) {
                if (voxelX >= -4 && voxelX <= -1) {
                    // Right leg
                    partName = 'rightleg';
                    localX = voxelX + 4; // -4 to -1 becomes 0 to 3
                    localY = voxelY - 26; // 26 to 37 becomes 0 to 11
                    localZ = voxelZ + 2; // -2 to 1 becomes 0 to 3
                } else if (voxelX >= 0 && voxelX <= 3) {
                    // Left leg
                    partName = 'leftleg';
                    localX = voxelX; // 0 to 3 stays 0 to 3
                    localY = voxelY - 26; // 26 to 37 becomes 0 to 11
                    localZ = voxelZ + 2; // -2 to 1 becomes 0 to 3
                }
            }
            
            return getTextureCoordinatesForBodyPart(partName, localX, localY, localZ, faceName);
        }

        function getTextureCoordinatesForBodyPart(partName, localX, localY, localZ, faceName) {
            // Minecraft skin texture layout mapping
            // This function maps each face of each body part to the correct texture coordinates
            
            switch (partName) {
                case 'head':
                    switch (faceName) {
                        case 'front': return { x: 8 + localX, y: 8 + (7 - localY) };
                        case 'back': return { x: 24 + localX, y: 8 + (7 - localY) };
                        case 'right': return { x: 0 + localZ, y: 8 + (7 - localY) };
                        case 'left': return { x: 16 + localZ, y: 8 + (7 - localY) };
                        case 'top': return { x: 8 + localX, y: 0 + localZ };
                        case 'bottom': return { x: 16 + localX, y: 0 + (7 - localZ) };
                    }
                    break;
                    
                case 'body':
                    switch (faceName) {
                        case 'front': return { x: 20 + localX, y: 20 + (11 - localY) };
                        case 'back': return { x: 32 + localX, y: 20 + (11 - localY) };
                        case 'right': return { x: 16 + localZ, y: 20 + (11 - localY) };
                        case 'left': return { x: 28 + localZ, y: 20 + (11 - localY) };
                        case 'top': return { x: 20 + localX, y: 16 + localZ };
                        case 'bottom': return { x: 28 + localX, y: 16 + (3 - localZ) };
                    }
                    break;
                    
                case 'rightarm':
                    switch (faceName) {
                        case 'front': return { x: 44 + localX, y: 20 + (11 - localY) };
                        case 'back': return { x: 52 + localX, y: 20 + (11 - localY) };
                        case 'right': return { x: 40 + localZ, y: 20 + (11 - localY) };
                        case 'left': return { x: 48 + localZ, y: 20 + (11 - localY) };
                        case 'top': return { x: 44 + localX, y: 16 + localZ };
                        case 'bottom': return { x: 48 + localX, y: 16 + (3 - localZ) };
                    }
                    break;
                    
                case 'leftarm':
                    switch (faceName) {
                        case 'front': return { x: 36 + localX, y: 52 + (11 - localY) };
                        case 'back': return { x: 44 + localX, y: 52 + (11 - localY) };
                        case 'right': return { x: 32 + localZ, y: 52 + (11 - localY) };
                        case 'left': return { x: 40 + localZ, y: 52 + (11 - localY) };
                        case 'top': return { x: 36 + localX, y: 48 + localZ };
                        case 'bottom': return { x: 40 + localX, y: 48 + (3 - localZ) };
                    }
                    break;
                    
                case 'rightleg':
                    switch (faceName) {
                        case 'front': return { x: 4 + localX, y: 20 + (11 - localY) };
                        case 'back': return { x: 12 + localX, y: 20 + (11 - localY) };
                        case 'right': return { x: 0 + localZ, y: 20 + (11 - localY) };
                        case 'left': return { x: 8 + localZ, y: 20 + (11 - localY) };
                        case 'top': return { x: 4 + localX, y: 16 + localZ };
                        case 'bottom': return { x: 8 + localX, y: 16 + (3 - localZ) };
                    }
                    break;
                    
                case 'leftleg':
                    switch (faceName) {
                        case 'front': return { x: 20 + localX, y: 52 + (11 - localY) };
                        case 'back': return { x: 28 + localX, y: 52 + (11 - localY) };
                        case 'right': return { x: 16 + localZ, y: 52 + (11 - localY) };
                        case 'left': return { x: 24 + localZ, y: 52 + (11 - localY) };
                        case 'top': return { x: 20 + localX, y: 48 + localZ };
                        case 'bottom': return { x: 24 + localX, y: 48 + (3 - localZ) };
                    }
                    break;
            }
            
            // Fallback
            return { x: 0, y: 0 };
        }

        function createGridOverlay() {
            gridOverlay = new THREE.Group();
            
            if (showPixelGrid) {
                if (layerVisibility.body) {
                    const gridMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.6,
                        linewidth: 2
                    });
                    
                    createPartGrid('head_body', -4, 4, 50, 58, -4, 4, gridMaterial, 1.0, false);
                    createPartGrid('body_body', -4, 4, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('rightarm_body', -7, -3, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('leftarm_body', 3, 7, 38, 50, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('rightleg_body', -4, 0, 26, 38, -2, 2, gridMaterial, 1.0, false);
                    createPartGrid('leftleg_body', 0, 4, 26, 38, -2, 2, gridMaterial, 1.0, false);
                }
                
                if (layerVisibility.outer) {
                    const outerGridMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xff6600,
                        transparent: true, 
                        opacity: 0.4,
                        linewidth: 1
                    });
                    
                    // FIXED: Outer grid uses same positioning as outer layer
                    createPartGrid('head_outer', -4, 4, 50, 58, -4, 4, outerGridMaterial, 1.1, true);
                    createPartGrid('body_outer', -4, 4, 38, 50, -2, 2, outerGridMaterial, 1.1, true);
                    createPartGrid('rightarm_outer', -7, -3, 38, 50, -2, 2, outerGridMaterial, 1.1, true);
                    createPartGrid('leftarm_outer', 3, 7, 38, 50, -2, 2, outerGridMaterial, 1.1, true);
                    createPartGrid('rightleg_outer', -4, 0, 26, 38, -2, 2, outerGridMaterial, 1.1, true);
                    createPartGrid('leftleg_outer', 0, 4, 26, 38, -2, 2, outerGridMaterial, 1.1, true);
                }
            }
            
            scene.add(gridOverlay);
        }

        function createPartGrid(partName, xMin, xMax, yMin, yMax, zMin, zMax, material, scale, isOuter = false) {
            const partGrid = new THREE.Group();
            partGrid.name = `grid_${partName}`;
            
            // Create grid lines at base size
            for (let x = xMin; x <= xMax; x++) {
                for (let y = yMin; y <= yMax; y++) {
                    const baseX = x * 0.125;
                    const baseY = y * 0.125;
                    
                    if ((x === xMin || x === xMax) || (y === yMin || y === yMax)) {
                        const zGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(baseX, baseY, zMin * 0.125),
                            new THREE.Vector3(baseX, baseY, zMax * 0.125)
                        ]);
                        partGrid.add(new THREE.Line(zGeometry, material));
                    }
                }
                
                for (let z = zMin; z <= zMax; z++) {
                    const baseX = x * 0.125;
                    const baseZ = z * 0.125;
                    
                    if ((x === xMin || x === xMax) || (z === zMin || z === zMax)) {
                        const yGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(baseX, yMin * 0.125, baseZ),
                            new THREE.Vector3(baseX, yMax * 0.125, baseZ)
                        ]);
                        partGrid.add(new THREE.Line(yGeometry, material));
                    }
                }
            }
            
            for (let y = yMin; y <= yMax; y++) {
                for (let z = zMin; z <= zMax; z++) {
                    const baseY = y * 0.125;
                    const baseZ = z * 0.125;
                    
                    if ((y === yMin || y === yMax) || (z === zMin || z === zMax)) {
                        const xGeometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(xMin * 0.125, baseY, baseZ),
                            new THREE.Vector3(xMax * 0.125, baseY, baseZ)
                        ]);
                        partGrid.add(new THREE.Line(xGeometry, material));
                    }
                }
            }
            
            // FIXED: Apply same positioning as outer layer
            if (isOuter) {
                const centerX = (xMin + xMax) / 2;
                const centerY = (yMin + yMax) / 2;
                const centerZ = (zMin + zMax) / 2;
                
                partGrid.scale.set(scale, scale, scale);
                
                const bodyCenter = new THREE.Vector3(centerX * 0.125, centerY * 0.125, centerZ * 0.125);
                partGrid.position.copy(bodyCenter);
                partGrid.position.multiplyScalar(1 - scale);
            }
            
            gridOverlay.add(partGrid);
        }

        function updateSkinTextures() {
            if (!skinModel) return;
            
            skinModel.children.forEach(layerGroup => {
                layerGroup.children.forEach(partGroup => {
                    partGroup.children.forEach(face => {
                        if (face.userData) {
                            const { voxelX, voxelY, voxelZ, layer, face: faceName } = face.userData;
                            
                            const texCoords = getVoxelFaceTextureCoords(voxelX, voxelY, voxelZ, faceName);
                            if (texCoords) {
                                const material = getVoxelMaterial(texCoords.x, texCoords.y, layer);
                                face.material.color.setHex(material.color);
                                face.material.opacity = material.opacity;
                                face.visible = material.opacity > 0 || layerVisibility[layer];
                            }
                        }
                    });
                });
            });
        }

        function setupEventListeners() {
            document.getElementById('color-picker').addEventListener('change', (e) => {
                currentColor = e.target.value;
                document.getElementById('color-code-input').value = e.target.value;
            });
            
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('toggleMode').addEventListener('click', toggleMode);
            document.getElementById('zoomIn').addEventListener('click', () => zoomCamera(0.9));
            document.getElementById('zoomOut').addEventListener('click', () => zoomCamera(1.1));
            
            document.getElementById('import-skin').addEventListener('change', importSkin);
            
            document.addEventListener('keydown', handleKeyboard);
        }

        function handleKeyboard(event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key) {
                    case 'z':
                        event.preventDefault();
                        if (event.shiftKey) {
                            redoAction();
                        } else {
                            undoAction();
                        }
                        break;
                    case 'y':
                        event.preventDefault();
                        redoAction();
                        break;
                }
            }
            
            switch (event.key) {
                case 'p':
                    setTool('pen');
                    break;
                case 'b':
                    setTool('brush');
                    break;
                case 'i':
                    setTool('eyedropper');
                    break;
                case 'r':
                    setTool('rotate');
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.querySelector('.skin-preview');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Tool functions
        function setTool(tool) {
            currentTool = tool;
            
            document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tool-${tool}`).classList.add('active');
            
            const canvas = renderer.domElement;
            if (tool === 'rotate' || !isEditMode) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            let toolDescription = '';
            switch(tool) {
                case 'pen':
                    toolDescription = 'Pen Tool - draws with exact current color';
                    break;
                case 'brush':
                    toolDescription = 'Brush Tool - draws with random brightness variations';
                    break;
                case 'eyedropper':
                    toolDescription = 'Color Picker - click to pick colors from the model';
                    break;
                case 'rotate':
                    toolDescription = 'Rotate View - drag to rotate the camera';
                    break;
            }
            updateStatus(toolDescription);
        }

        // Layer functions
        function toggleLayerVisibility(layer) {
            layerVisibility[layer] = !layerVisibility[layer];
            
            updateCurrentEditingLayer();
            
            updateLayerButtons();
            updateLayerDisplay();
            updateLayerVisibility3D();
            updateGridOverlay();
            
            const status = layerVisibility[layer] ? 'shown' : 'hidden';
            updateStatus(`${layer} layer ${status}`);
        }

        function updateCurrentEditingLayer() {
            if (layerVisibility.outer) {
                currentEditingLayer = 'outer';
            } else if (layerVisibility.body) {
                currentEditingLayer = 'body';
            } else {
                currentEditingLayer = 'body';
                layerVisibility.body = true;
            }
        }

        function updateLayerVisibility3D() {
            if (!skinModel) return;
            
            skinModel.children.forEach(layerGroup => {
                if (layerGroup.name === 'body_layer') {
                    layerGroup.visible = layerVisibility.body;
                } else if (layerGroup.name === 'outer_layer') {
                    layerGroup.visible = layerVisibility.outer;
                }
            });
            
            updateSkinTextures();
        }

        function togglePixelGrid() {
            showPixelGrid = !showPixelGrid;
            updatePixelGridButton();
            updateGridOverlay();
            updateSkinTextures();
            
            const status = showPixelGrid ? 'shown' : 'hidden';
            updateStatus(`Pixel grid ${status}`);
        }

        function updateGridOverlay() {
            if (gridOverlay) {
                scene.remove(gridOverlay);
            }
            createGridOverlay();
        }

        function updateLayerButtons() {
            const bodyLayerBtn = document.getElementById('layer-body');
            const outerLayerBtn = document.getElementById('layer-outer');
            
            bodyLayerBtn.classList.toggle('visible', layerVisibility.body);
            bodyLayerBtn.classList.remove('editing');
            bodyLayerBtn.textContent = 'Body';
            
            outerLayerBtn.classList.toggle('visible', layerVisibility.outer);
            outerLayerBtn.classList.remove('editing');
            outerLayerBtn.textContent = 'Outer';
        }

        function updatePixelGridButton() {
            const gridBtn = document.getElementById('pixel-grid-btn');
            gridBtn.classList.toggle('visible', showPixelGrid);
            gridBtn.textContent = 'Grid';
        }

        function toggleBodyPart(partName) {
            bodyPartsVisible[partName] = !bodyPartsVisible[partName];
            
            const btn = document.getElementById(`part-${partName}`);
            
            skinModel.children.forEach(layerGroup => {
                layerGroup.children.forEach(partGroup => {
                    if (partGroup.name.includes(partName)) {
                        partGroup.visible = bodyPartsVisible[partName];
                    }
                });
            });
            
            if (bodyPartsVisible[partName]) {
                btn.classList.remove('hidden');
                updateStatus(`${partName} shown`);
            } else {
                btn.classList.add('hidden');
                updateStatus(`${partName} hidden`);
            }
        }

        function updateLayerDisplay() {
            const indicator = document.getElementById('edit-mode-indicator');
            
            if (currentEditingLayer === 'body') {
                indicator.textContent = 'Editing: Body Layer';
                indicator.style.background = 'rgba(76, 175, 80, 0.9)';
            } else {
                indicator.textContent = 'Editing: Outer Layer';
                indicator.style.background = 'rgba(255, 152, 0, 0.9)';
            }
        }

        function toggleMode() {
            isEditMode = !isEditMode;
            
            const toggleBtn = document.getElementById('toggleMode');
            const canvas = renderer.domElement;
            
            if (isEditMode) {
                toggleBtn.textContent = '👁️ View Mode';
                if (currentTool === 'rotate') {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            } else {
                toggleBtn.textContent = '🎨 Edit Mode';
                canvas.style.cursor = 'grab';
            }
        }

        function resetView() {
            camera.position.set(5, 6, 5);
            camera.lookAt(0, 6, 0);
            updateCameraInfo();
        }

        function zoomCamera(factor) {
            const targetPosition = new THREE.Vector3(0, 6, 0);
            const offset = camera.position.clone().sub(targetPosition);
            offset.multiplyScalar(factor);
            
            const distance = offset.length();
            if (distance < 3) offset.setLength(3);
            if (distance > 12) offset.setLength(12);
            
            camera.position.copy(targetPosition).add(offset);
            camera.lookAt(targetPosition);
            
            updateCameraInfo();
        }

        // Color functions
        function generateColorPalette() {
            const paletteContainer = document.getElementById('color-palette');
            paletteContainer.innerHTML = '';
            
            commonColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.width = '30px';
                swatch.style.height = '30px';
                swatch.style.backgroundColor = color;
                swatch.style.border = '2px solid #8b4513';
                swatch.style.borderRadius = '3px';
                swatch.style.cursor = 'pointer';
                swatch.style.transition = 'transform 0.2s';
                
                swatch.addEventListener('click', () => {
                    currentColor = color;
                    document.getElementById('color-picker').value = color;
                    document.getElementById('color-code-input').value = color;
                    updateStatus(`Color selected: ${color}`);
                });
                
                swatch.addEventListener('mouseenter', () => {
                    swatch.style.transform = 'scale(1.1)';
                });
                
                swatch.addEventListener('mouseleave', () => {
                    swatch.style.transform = 'scale(1.0)';
                });
                
                paletteContainer.appendChild(swatch);
            });
        }

        function applyColorCode() {
            const colorInput = document.getElementById('color-code-input');
            let colorCode = colorInput.value.trim();
            
            if (!colorCode.startsWith('#')) {
                colorCode = '#' + colorCode;
            }
            
            if (/^#[0-9A-F]{6}$/i.test(colorCode)) {
                currentColor = colorCode.toLowerCase();
                document.getElementById('color-picker').value = currentColor;
                updateStatus(`Color applied: ${currentColor}`);
            } else {
                updateStatus('Invalid color code! Use format: #RRGGBB');
                colorInput.value = currentColor;
            }
        }

        // Undo/Redo functions
        function saveUndoState() {
            const state = {
                body: new Uint8ClampedArray(skinData.body),
                outer: new Uint8ClampedArray(skinData.outer)
            };
            
            undoStack.push(state);
            
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            redoStack = [];
        }

        function undoAction() {
            if (undoStack.length === 0) {
                updateStatus('Nothing to undo');
                return;
            }
            
            const currentState = {
                body: new Uint8ClampedArray(skinData.body),
                outer: new Uint8ClampedArray(skinData.outer)
            };
            redoStack.push(currentState);
            
            const previousState = undoStack.pop();
            skinData.body.set(previousState.body);
            skinData.outer.set(previousState.outer);
            
            updateSkinTextures();
            updateStatus('Undo applied');
        }

        function redoAction() {
            if (redoStack.length === 0) {
                updateStatus('Nothing to redo');
                return;
            }
            
            saveUndoState();
            undoStack.pop();
            
            const redoState = redoStack.pop();
            skinData.body.set(redoState.body);
            skinData.outer.set(redoState.outer);
            
            updateSkinTextures();
            updateStatus('Redo applied');
        }

        function mirrorSkin() {
            saveUndoState();
            
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 0; y < 64; y++) {
                for (let x = 0; x < 32; x++) {
                    const leftIndex = (y * 64 + x) * 4;
                    const rightIndex = (y * 64 + (63 - x)) * 4;
                    
                    data[rightIndex] = tempData[leftIndex];
                    data[rightIndex + 1] = tempData[leftIndex + 1];
                    data[rightIndex + 2] = tempData[leftIndex + 2];
                    data[rightIndex + 3] = tempData[leftIndex + 3];
                }
            }
            
            updateSkinTextures();
            updateStatus('Skin mirrored');
        }

        function flipSkin() {
            saveUndoState();
            
            const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 0; y < 32; y++) {
                for (let x = 0; x < 64; x++) {
                    const topIndex = (y * 64 + x) * 4;
                    const bottomIndex = ((63 - y) * 64 + x) * 4;
                    
                    data[bottomIndex] = tempData[topIndex];
                    data[bottomIndex + 1] = tempData[topIndex + 1];
                    data[bottomIndex + 2] = tempData[topIndex + 2];
                    data[bottomIndex + 3] = tempData[topIndex + 3];
                    
                    data[topIndex] = tempData[bottomIndex];
                    data[topIndex + 1] = tempData[bottomIndex + 1];
                    data[topIndex + 2] = tempData[bottomIndex + 2];
                    data[topIndex + 3] = tempData[bottomIndex + 3];
                }
            }
            
            updateSkinTextures();
            updateStatus('Skin flipped');
        }

        // File operations
        function exportSkin() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Export both layers combined into a single skin file
            const combinedData = new Uint8ClampedArray(64 * 64 * 4);
            
            // Start with body layer as base
            combinedData.set(skinData.body);
            
            // Overlay outer layer data where it exists
            for (let i = 0; i < skinData.outer.length; i += 4) {
                if (skinData.outer[i + 3] > 0) { // If outer layer pixel is not transparent
                    combinedData[i] = skinData.outer[i];
                    combinedData[i + 1] = skinData.outer[i + 1];
                    combinedData[i + 2] = skinData.outer[i + 2];
                    combinedData[i + 3] = skinData.outer[i + 3];
                }
            }
            
            const imageData = new ImageData(combinedData, 64, 64);
            ctx.putImageData(imageData, 0, 0);
            
            const link = document.createElement('a');
            link.download = 'minecraft_skin_3d.png';
            link.href = canvas.toDataURL();
            link.click();
            
            updateStatus('3D skin exported successfully!');
        }

        // FIXED: Import function now properly extracts both body and outer layers
        function importSkin(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Draw the image to canvas and get pixel data
                ctx.drawImage(img, 0, 0, 64, 64);
                const imageData = ctx.getImageData(0, 0, 64, 64);
                const pixels = imageData.data;
                
                // Clear both layers first
                skinData.body.fill(0);
                skinData.outer.fill(0);
                
                // Extract body layer and outer layer from the standard Minecraft skin format
                extractSkinLayers(pixels);
                
                // Save original head data after import
                saveOriginalHeadData();
                
                // Enable both layers for viewing
                layerVisibility.body = true;
                layerVisibility.outer = true;
                
                updateLayerButtons();
                updateLayerVisibility3D();
                updateSkinTextures();
                updateStatus(`3D skin imported: ${file.name} - Both layers extracted`);
            };
            
            img.src = URL.createObjectURL(file);
            e.target.value = '';
        }

        function extractSkinLayers(pixels) {
            // Minecraft skin format has body layer and outer layer areas defined
            // Body layer areas (main skin)
            const bodyAreas = [
                { x: 8, y: 8, w: 8, h: 8 },    // Head front
                { x: 0, y: 8, w: 8, h: 8 },    // Head right
                { x: 16, y: 8, w: 8, h: 8 },   // Head left  
                { x: 24, y: 8, w: 8, h: 8 },   // Head back
                { x: 8, y: 0, w: 8, h: 8 },    // Head top
                { x: 16, y: 0, w: 8, h: 8 },   // Head bottom
                
                { x: 20, y: 20, w: 8, h: 12 }, // Body front
                { x: 16, y: 20, w: 4, h: 12 }, // Body right
                { x: 28, y: 20, w: 4, h: 12 }, // Body left
                { x: 32, y: 20, w: 8, h: 12 }, // Body back
                { x: 20, y: 16, w: 8, h: 4 },  // Body top
                { x: 28, y: 16, w: 8, h: 4 },  // Body bottom
                
                { x: 44, y: 20, w: 4, h: 12 }, // Right arm front
                { x: 40, y: 20, w: 4, h: 12 }, // Right arm right
                { x: 48, y: 20, w: 4, h: 12 }, // Right arm left
                { x: 52, y: 20, w: 4, h: 12 }, // Right arm back
                { x: 44, y: 16, w: 4, h: 4 },  // Right arm top
                { x: 48, y: 16, w: 4, h: 4 },  // Right arm bottom
                
                { x: 36, y: 52, w: 4, h: 12 }, // Left arm front
                { x: 32, y: 52, w: 4, h: 12 }, // Left arm right
                { x: 40, y: 52, w: 4, h: 12 }, // Left arm left
                { x: 44, y: 52, w: 4, h: 12 }, // Left arm back
                { x: 36, y: 48, w: 4, h: 4 },  // Left arm top
                { x: 40, y: 48, w: 4, h: 4 },  // Left arm bottom
                
                { x: 4, y: 20, w: 4, h: 12 },  // Right leg front
                { x: 0, y: 20, w: 4, h: 12 },  // Right leg right
                { x: 8, y: 20, w: 4, h: 12 },  // Right leg left
                { x: 12, y: 20, w: 4, h: 12 }, // Right leg back
                { x: 4, y: 16, w: 4, h: 4 },   // Right leg top
                { x: 8, y: 16, w: 4, h: 4 },   // Right leg bottom
                
                { x: 20, y: 52, w: 4, h: 12 }, // Left leg front
                { x: 16, y: 52, w: 4, h: 12 }, // Left leg right
                { x: 24, y: 52, w: 4, h: 12 }, // Left leg left
                { x: 28, y: 52, w: 4, h: 12 }, // Left leg back
                { x: 20, y: 48, w: 4, h: 4 },  // Left leg top
                { x: 24, y: 48, w: 4, h: 4 }   // Left leg bottom
            ];
            
            // Outer layer areas (overlay/clothing)
            const outerAreas = [
                { x: 40, y: 8, w: 8, h: 8 },   // Head outer front
                { x: 32, y: 8, w: 8, h: 8 },   // Head outer right
                { x: 48, y: 8, w: 8, h: 8 },   // Head outer left
                { x: 56, y: 8, w: 8, h: 8 },   // Head outer back
                { x: 40, y: 0, w: 8, h: 8 },   // Head outer top
                { x: 48, y: 0, w: 8, h: 8 },   // Head outer bottom
                
                { x: 20, y: 36, w: 8, h: 12 }, // Body outer front
                { x: 16, y: 36, w: 4, h: 12 }, // Body outer right
                { x: 28, y: 36, w: 4, h: 12 }, // Body outer left
                { x: 32, y: 36, w: 8, h: 12 }, // Body outer back
                { x: 20, y: 32, w: 8, h: 4 },  // Body outer top
                { x: 28, y: 32, w: 8, h: 4 },  // Body outer bottom
                
                { x: 44, y: 36, w: 4, h: 12 }, // Right arm outer front
                { x: 40, y: 36, w: 4, h: 12 }, // Right arm outer right
                { x: 48, y: 36, w: 4, h: 12 }, // Right arm outer left
                { x: 52, y: 36, w: 4, h: 12 }, // Right arm outer back
                { x: 44, y: 32, w: 4, h: 4 },  // Right arm outer top
                { x: 48, y: 32, w: 4, h: 4 },  // Right arm outer bottom
                
                { x: 52, y: 52, w: 4, h: 12 }, // Left arm outer front
                { x: 48, y: 52, w: 4, h: 12 }, // Left arm outer right
                { x: 56, y: 52, w: 4, h: 12 }, // Left arm outer left
                { x: 60, y: 52, w: 4, h: 12 }, // Left arm outer back
                { x: 52, y: 48, w: 4, h: 4 },  // Left arm outer top
                { x: 56, y: 48, w: 4, h: 4 },  // Left arm outer bottom
                
                { x: 4, y: 36, w: 4, h: 12 },  // Right leg outer front
                { x: 0, y: 36, w: 4, h: 12 },  // Right leg outer right
                { x: 8, y: 36, w: 4, h: 12 },  // Right leg outer left
                { x: 12, y: 36, w: 4, h: 12 }, // Right leg outer back
                { x: 4, y: 32, w: 4, h: 4 },   // Right leg outer top
                { x: 8, y: 32, w: 4, h: 4 },   // Right leg outer bottom
                
                { x: 4, y: 52, w: 4, h: 12 },  // Left leg outer front
                { x: 0, y: 52, w: 4, h: 12 },  // Left leg outer right
                { x: 8, y: 52, w: 4, h: 12 },  // Left leg outer left
                { x: 12, y: 52, w: 4, h: 12 }, // Left leg outer back
                { x: 4, y: 48, w: 4, h: 4 },   // Left leg outer top
                { x: 8, y: 48, w: 4, h: 4 }    // Left leg outer bottom
            ];
            
            // Copy body layer areas
            bodyAreas.forEach(area => {
                copyPixelArea(pixels, skinData.body, area.x, area.y, area.w, area.h, area.x, area.y);
            });
            
            // Copy outer layer areas to their corresponding body positions
            outerAreas.forEach((area, index) => {
                if (index < bodyAreas.length) {
                    const targetArea = bodyAreas[index];
                    copyPixelArea(pixels, skinData.outer, area.x, area.y, area.w, area.h, targetArea.x, targetArea.y);
                }
            });
        }

        function copyPixelArea(sourcePixels, targetData, srcX, srcY, width, height, dstX, dstY) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcIndex = ((srcY + y) * 64 + (srcX + x)) * 4;
                    const dstIndex = ((dstY + y) * 64 + (dstX + x)) * 4;
                    
                    if (srcIndex >= 0 && srcIndex < sourcePixels.length && 
                        dstIndex >= 0 && dstIndex < targetData.length) {
                        targetData[dstIndex] = sourcePixels[srcIndex];
                        targetData[dstIndex + 1] = sourcePixels[srcIndex + 1];
                        targetData[dstIndex + 2] = sourcePixels[srcIndex + 2];
                        targetData[dstIndex + 3] = sourcePixels[srcIndex + 3];
                    }
                }
            }
        }

        function newSkin() {
            if (confirm('Load a new Steve skin? This will replace your current work.')) {
                saveUndoState();
                loadSteveSkin();
                updateStatus('Loading new Steve skin...');
            }
        }

        function clearSkin() {
            if (confirm(`Clear the ${currentEditingLayer} layer? This will remove all colors from this layer.`)) {
                saveUndoState();
                
                const data = currentEditingLayer === 'body' ? skinData.body : skinData.outer;
                data.fill(0);
                
                updateSkinTextures();
                updateStatus(`${currentEditingLayer} layer cleared`);
            }
        }

        function updateCameraInfo() {
            const targetPosition = new THREE.Vector3(0, 6, 0);
            const distance = Math.round(camera.position.distanceTo(targetPosition) * 10) / 10;
            const zoom = Math.round((4 / distance) * 100);
            document.getElementById('camera-info').textContent = `Camera: ${isEditMode ? 'Edit' : 'View'} | Zoom: ${zoom}%`;
        }

        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
            
            const toolNames = {
                'pen': 'Pen',
                'brush': 'Brush', 
                'eyedropper': 'Picker',
                'rotate': 'Rotate'
            };
            
            document.getElementById('pixel-info').textContent = `Editing: ${currentEditingLayer === 'body' ? 'Body' : 'Outer'} Layer | Tool: ${toolNames[currentTool]}`;
        }

        // Utility functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        console.log('🎮 3D Minecraft Skin Editor with JSON-based AI generation loaded successfully!');
    </script>

</body>
</html>